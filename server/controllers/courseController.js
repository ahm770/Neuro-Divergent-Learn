// ===== File: /controllers/courseController.js =====
const Course = require('../models/Course');
const Module = require('../models/Module');
const Lesson = require('../models/Lesson'); // For cascading deletes or operations
const User = require('../models/User');
const mongoose = require('mongoose');
const { validationResult, body } = require('express-validator');
const logAction = require('../utils/auditLogger');


exports.courseCreateValidation = [
    body('title').trim().isLength({ min: 3 }).withMessage('Course title must be at least 3 characters.'),
    body('description').optional().trim(),
    body('category').optional().trim(),
    body('coverImage').optional().isURL().withMessage('Invalid cover image URL.'),
    body('globalLearningObjectives').optional().isArray(),
    body('published').optional().isBoolean()
];

exports.createCourse = async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
    }

    try {
        const { title, description, category, coverImage, globalLearningObjectives, published } = req.body;
        const slug = title.toLowerCase().trim().replace(/\s+/g, '-').replace(/[^\w-]+/g, '');

        const existingCourse = await Course.findOne({ slug });
        if (existingCourse) {
            return res.status(400).json({ error: `Course with title "${title}" resulting in slug "${slug}" already exists.` });
        }

        const course = new Course({
            title,
            description,
            slug, // slug will be auto-generated by pre-save hook if not provided here explicitly
            category,
            coverImage,
            globalLearningObjectives: globalLearningObjectives || [],
            published: published || false,
            createdBy: req.user._id,
            instructorIds: [req.user._id] // Creator is initially an instructor
        });

        await course.save();

        await logAction(req.user.id, 'CREATE_COURSE', 'Course', course._id, { title: course.title, slug: course.slug }, req.ip);
        res.status(201).json(course);
    } catch (error) {
        console.error("Create Course Error:", error);
        res.status(500).json({ error: 'Failed to create course.' });
    }
};

exports.getAllCourses = async (req, res) => {
    try {
        // For admin/creator: list all courses for management
        // For students: list published courses they can enroll in (or are enrolled in)
        const query = {};
        if (req.user.role !== 'admin' && req.user.role !== 'creator') {
            query.published = true; // Students only see published courses
        }
        // Add pagination, search, filtering as needed, similar to contentController.getAllContent
        const courses = await Course.find(query)
            .populate('createdBy', 'name email')
            .populate('instructorIds', 'name email')
            .sort({ createdAt: -1 });
        res.json(courses);
    } catch (error) {
        console.error("Get All Courses Error:", error);
        res.status(500).json({ error: 'Failed to retrieve courses.' });
    }
};

exports.getCourseByIdOrSlug = async (req, res) => {
    try {
        const identifier = req.params.identifier;
        let course;

        if (mongoose.Types.ObjectId.isValid(identifier)) {
            course = await Course.findById(identifier);
        } else {
            course = await Course.findOne({ slug: identifier });
        }

        if (!course) {
            return res.status(404).json({ error: 'Course not found.' });
        }
        // Further populate modules and lessons if needed for detail view
        // Example: .populate({ path: 'modules', populate: { path: 'lessons' } })
        await course.populate([
            { path: 'createdBy', select: 'name email' },
            { path: 'instructorIds', select: 'name email' },
            {
                path: 'modules',
                options: { sort: { order: 1 } }, // Sort modules by order
                populate: {
                    path: 'lessons',
                    options: { sort: { order: 1 } }, // Sort lessons by order
                    populate: { // Populate items within lessons
                        path: 'items.itemId',
                        select: 'title topic originalText' // Select fields relevant for display
                    }
                }
            }
        ]);


        if (!course.published && (!req.user || (req.user.role !== 'admin' && req.user.role !== 'creator' && !course.instructorIds.map(id => id.toString()).includes(req.user._id.toString())))) {
             return res.status(403).json({ error: 'You are not authorized to view this unpublished course.' });
        }

        res.json(course);
    } catch (error) {
        console.error("Get Course By ID/Slug Error:", error);
        res.status(500).json({ error: 'Failed to retrieve course.' });
    }
};


exports.updateCourse = async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
    }
    try {
        const courseId = req.params.id;
        const { title, description, category, coverImage, globalLearningObjectives, published, instructorIds } = req.body;

        const course = await Course.findById(courseId);
        if (!course) {
            return res.status(404).json({ error: 'Course not found.' });
        }

        // Authorization: Only admin, creator, or instructor of the course can update
        if (req.user.role !== 'admin' && req.user.role !== 'creator' && !course.instructorIds.map(id => id.toString()).includes(req.user._id.toString())) {
            return res.status(403).json({ error: 'Not authorized to update this course.' });
        }
        
        const oldValues = {
            title: course.title,
            published: course.published,
        };

        if (title) {
            course.title = title;
            course.slug = title.toLowerCase().trim().replace(/\s+/g, '-').replace(/[^\w-]+/g, '');
            // Check if new slug conflicts (excluding current course)
            const conflictingCourse = await Course.findOne({ slug: course.slug, _id: { $ne: course._id } });
            if (conflictingCourse) {
                 return res.status(400).json({ error: `A course with the title "${title}" (slug: "${course.slug}") already exists.` });
            }
        }
        if (description !== undefined) course.description = description;
        if (category !== undefined) course.category = category;
        if (coverImage !== undefined) course.coverImage = coverImage;
        if (globalLearningObjectives !== undefined) course.globalLearningObjectives = globalLearningObjectives;
        if (published !== undefined) course.published = published;
        
        if (instructorIds && Array.isArray(instructorIds)) {
            // Validate instructorIds are valid user ObjectIds
            const validInstructors = await User.find({ _id: { $in: instructorIds }, role: { $in: ['admin', 'creator'] } }).select('_id');
            course.instructorIds = validInstructors.map(u => u._id);
        }

        course.lastUpdatedBy = req.user._id;
        await course.save();
        
        const changes = {};
        if(oldValues.title !== course.title) changes.title = {old: oldValues.title, new: course.title};
        if(oldValues.published !== course.published) changes.published = {old: oldValues.published, new: course.published};
        // Add more fields to changes if needed for audit log

        if (Object.keys(changes).length > 0) {
            await logAction(req.user.id, 'UPDATE_COURSE', 'Course', course._id, { changes }, req.ip);
        }
        res.json(course);
    } catch (error) {
        console.error("Update Course Error:", error);
        if (error.code === 11000) { // Duplicate key error for slug
            return res.status(400).json({ error: 'A course with this title or resulting slug already exists.' });
        }
        res.status(500).json({ error: 'Failed to update course.' });
    }
};

exports.deleteCourse = async (req, res) => {
    try {
        const courseId = req.params.id;
        const course = await Course.findById(courseId);
        if (!course) {
            return res.status(404).json({ error: 'Course not found.' });
        }

        // Authorization: Only admin or original creator (or specific high-level creator)
        if (req.user.role !== 'admin' && course.createdBy.toString() !== req.user._id.toString()) {
             return res.status(403).json({ error: 'Not authorized to delete this course.' });
        }
        
        const deletedTitle = course.title;

        // Potentially complex: Delete all associated modules, lessons, and lesson items (Content, Quizzes etc.)
        // This requires careful handling and could be resource-intensive.
        // For now, let's just delete the course. A more robust solution would handle children.
        // Example for children (use with caution, might need transactions for all-or-nothing):
        // await Module.deleteMany({ courseId: course._id }); // And then lessons for each module, etc.

        await course.deleteOne();

        await logAction(req.user.id, 'DELETE_COURSE', 'Course', courseId, { title: deletedTitle, slug: course.slug }, req.ip);
        res.json({ message: `Course "${deletedTitle}" deleted successfully.` });
    } catch (error) {
        console.error("Delete Course Error:", error);
        res.status(500).json({ error: 'Failed to delete course.' });
    }
};

// --- Student Enrollment ---
exports.enrollInCourse = async (req, res) => {
    try {
        const courseId = req.params.id;
        const userId = req.user._id;

        const course = await Course.findById(courseId);
        if (!course || !course.published) {
            return res.status(404).json({ error: 'Published course not found.' });
        }

        if (course.studentIds.map(id => id.toString()).includes(userId.toString())) {
            return res.status(400).json({ message: 'Already enrolled in this course.' });
        }

        course.studentIds.push(userId);
        await course.save();
        await logAction(req.user.id, 'ENROLL_COURSE', 'Course', course._id, { courseTitle: course.title }, req.ip);
        res.json({ message: 'Successfully enrolled in the course.', course });
    } catch (error) {
        console.error("Enroll Course Error:", error);
        res.status(500).json({ error: 'Failed to enroll in course.' });
    }
};

exports.unenrollFromCourse = async (req, res) => {
    try {
        const courseId = req.params.id;
        const userId = req.user._id;

        const course = await Course.findById(courseId);
        if (!course) {
            return res.status(404).json({ error: 'Course not found.' });
        }

        const studentIndex = course.studentIds.map(id => id.toString()).indexOf(userId.toString());
        if (studentIndex === -1) {
            return res.status(400).json({ message: 'Not enrolled in this course.' });
        }

        course.studentIds.splice(studentIndex, 1);
        await course.save();
        await logAction(req.user.id, 'UNENROLL_COURSE', 'Course', course._id, { courseTitle: course.title }, req.ip);
        res.json({ message: 'Successfully unenrolled from the course.', course });
    } catch (error) {
        console.error("Unenroll Course Error:", error);
        res.status(500).json({ error: 'Failed to unenroll from course.' });
    }
};

exports.getEnrolledCourses = async (req, res) => {
    try {
        const userId = req.user._id;
        const courses = await Course.find({ studentIds: userId, published: true })
            .select('title slug description coverImage category')
            .sort({ title: 1 });
        res.json(courses);
    } catch (error) {
        console.error("Get Enrolled Courses Error:", error);
        res.status(500).json({ error: 'Failed to retrieve enrolled courses.' });
    }
};


// --- Module Management within a Course ---
exports.addModuleToCourse = async (req, res) => {
    try {
        const courseId = req.params.courseId;
        const { moduleId } = req.body; // Expecting moduleId to be added

        if (!mongoose.Types.ObjectId.isValid(moduleId)) {
            return res.status(400).json({ error: "Invalid module ID." });
        }

        const course = await Course.findById(courseId);
        if (!course) return res.status(404).json({ error: "Course not found." });

        // Authorization (creator/admin/instructor)
        if (req.user.role !== 'admin' && req.user.role !== 'creator' && !course.instructorIds.map(id => id.toString()).includes(req.user._id.toString())) {
            return res.status(403).json({ error: 'Not authorized to modify this course.' });
        }

        const moduleExists = await Module.findById(moduleId);
        if (!moduleExists || moduleExists.courseId.toString() !== courseId) { // Ensure module belongs to this course or is being assigned
            // If module exists but belongs to another course, this logic might need adjustment based on UX flow
            // For now, assume module is created for this course or being linked
            return res.status(404).json({ error: "Module not found or does not belong to this course if trying to link existing."});
        }
        
        if (course.modules.map(id => id.toString()).includes(moduleId)) {
            return res.status(400).json({ error: "Module already in this course." });
        }
        
        course.modules.push(moduleId);
        course.lastUpdatedBy = req.user._id;
        await course.save();

        await logAction(req.user.id, 'ADD_MODULE_TO_COURSE', 'Course', courseId, { moduleId }, req.ip);
        res.status(200).json(course);
    } catch (error) {
        console.error("Add module to course error:", error);
        res.status(500).json({ error: "Failed to add module." });
    }
};

exports.updateModulesOrderInCourse = async (req, res) => {
    try {
        const courseId = req.params.courseId;
        const { orderedModuleIds } = req.body; // Expecting an array of module ObjectIds in the new order

        if (!Array.isArray(orderedModuleIds) || !orderedModuleIds.every(id => mongoose.Types.ObjectId.isValid(id))) {
            return res.status(400).json({ error: "Invalid module IDs array." });
        }

        const course = await Course.findById(courseId);
        if (!course) return res.status(404).json({ error: "Course not found." });

        // Authorization
        if (req.user.role !== 'admin' && req.user.role !== 'creator' && !course.instructorIds.map(id => id.toString()).includes(req.user._id.toString())) {
            return res.status(403).json({ error: 'Not authorized to modify this course.' });
        }

        // Validate that all provided module IDs actually exist in the course's modules array
        const currentModuleIds = course.modules.map(id => id.toString());
        const allProvidedIdsInCourse = orderedModuleIds.every(id => currentModuleIds.includes(id.toString()));
        if (orderedModuleIds.length !== currentModuleIds.length || !allProvidedIdsInCourse) {
            return res.status(400).json({ error: "Module list mismatch. Ensure all current course modules are provided in the new order." });
        }

        course.modules = orderedModuleIds.map(id => new mongoose.Types.ObjectId(id)); // Update the order
        course.lastUpdatedBy = req.user._id;
        await course.save();
        
        // Optionally, update 'order' field in each Module document (more complex, might not be needed if array order is source of truth)
        // For each module ID in orderedModuleIds, find the Module and update its 'order' field.
        await Promise.all(orderedModuleIds.map(async (moduleId, index) => {
            await Module.findByIdAndUpdate(moduleId, { order: index });
        }));


        await logAction(req.user.id, 'REORDER_COURSE_MODULES', 'Course', courseId, { newOrderCount: orderedModuleIds.length }, req.ip);
        res.status(200).json(course);
    } catch (error) {
        console.error("Reorder modules error:", error);
        res.status(500).json({ error: "Failed to reorder modules." });
    }
};

// removeModuleFromCourse would also be needed