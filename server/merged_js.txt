
===== File: /utils/generateToken.js =====
// ===== File: /utils/generateToken.js =====
const jwt = require('jsonwebtoken');

const generateToken = (id) => {
  // Check if JWT_SECRET is set
  if (!process.env.JWT_SECRET) {
      // Throw an error instead of exiting, so it can be caught by a global error handler or at startup
      throw new Error('FATAL ERROR: JWT_SECRET is not defined in .env file.');
  }

  return jwt.sign({ id }, process.env.JWT_SECRET, {
    expiresIn: '30d', // Token expires in 30 days (adjust as needed)
  });
};

module.exports = generateToken;

===== File: /controllers/authController.js =====
const User = require('../models/User');
const generateToken = require('../utils/generateToken');
const { validationResult } = require('express-validator'); // For input validation

// Validation rules (can be moved to a separate validation file later)
const { body } = require('express-validator');

exports.signupValidation = [
  body('name').optional().trim().isLength({ min: 2 }).withMessage('Name must be at least 2 characters'),
  body('email').isEmail().withMessage('Please provide a valid email').normalizeEmail(),
  body('password').isLength({ min: 6 }).withMessage('Password must be at least 6 characters')
];

exports.loginValidation = [
  body('email').isEmail().withMessage('Please provide a valid email').normalizeEmail(),
  body('password').exists().withMessage('Password is required')
];


exports.signup = async (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }

  try {
    const { name, email, password } = req.body;

    const existingUser = await User.findOne({ email: email.toLowerCase() });
    if (existingUser) return res.status(400).json({ error: 'User already exists' });

    const user = await User.create({ name, email, password });

    res.status(201).json({
      _id: user._id,
      name: user.name,
      email: user.email,
      preferences: user.preferences,
      token: generateToken(user._id)
    });

  } catch (err) {
    console.error("Signup error:", err);
    res.status(500).json({ error: err.message || 'Server error during signup' });
  }
};

exports.login = async (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }

  try {
    const { email, password } = req.body;

    const user = await User.findOne({ email: email.toLowerCase() });
    if (!user || !(await user.matchPassword(password))) {
      return res.status(401).json({ error: 'Invalid email or password' });
    }

    res.json({
      _id: user._id,
      name: user.name,
      email: user.email,
      role: user.role,
      preferences: user.preferences,
      token: generateToken(user._id)
    });

  } catch (err) {
    console.error("Login error:", err);
    res.status(500).json({ error: err.message || 'Server error during login' });
  }
};

// Get current logged-in user's profile
exports.getMe = async (req, res) => {
    try {
        // req.user is populated by the 'protect' middleware
        const user = await User.findById(req.user.id).select('-password');
        if (!user) {
            return res.status(404).json({ error: 'User not found' });
        }
        res.json({
            _id: user._id,
            name: user.name,
            email: user.email,
            role: user.role,
            preferences: user.preferences,
            createdAt: user.createdAt
        });
    } catch (err) {
        console.error("GetMe error:", err);
        res.status(500).json({ error: 'Server error fetching user profile' });
    }
};

// Update user preferences
exports.updatePreferences = async (req, res) => {
    try {
        const userId = req.user.id;
        // Destructure all expected preference fields
        const {
            readingLevel,
            fontSize,
            theme,
            dyslexiaFontEnabled, // Added
            preferredContentMode,
            ttsEnabled
        } = req.body;

        const user = await User.findById(userId);
        if (!user) {
            return res.status(404).json({ error: 'User not found' });
        }

        // Validate and update preferences
        if (readingLevel && ['basic', 'intermediate', 'advanced'].includes(readingLevel)) {
            user.preferences.readingLevel = readingLevel;
        }
        if (fontSize && ['small', 'medium', 'large', 'xlarge'].includes(fontSize)) {
            user.preferences.fontSize = fontSize;
        }
        if (theme && ['light', 'dark', 'high-contrast'].includes(theme)) {
            user.preferences.theme = theme;
        }
        if (typeof dyslexiaFontEnabled === 'boolean') { // Added
            user.preferences.dyslexiaFontEnabled = dyslexiaFontEnabled;
        }
        if (preferredContentMode && ['text', 'video', 'visual', 'audio'].includes(preferredContentMode)) {
            user.preferences.preferredContentMode = preferredContentMode;
        }
        if (typeof ttsEnabled === 'boolean') {
            user.preferences.ttsEnabled = ttsEnabled;
        }

        await user.save();
        res.json({
            message: 'Preferences updated successfully',
            preferences: user.preferences // Send back the full updated preferences object
        });

    } catch (err) {
        console.error("UpdatePreferences error:", err);
        res.status(500).json({ error: 'Server error updating preferences' });
    }
};

===== File: /controllers/contentController.js =====
// ===== File: /server/controllers/contentController.js =====
const Content = require('../models/Content');
const User = require('../models/User');
const { GoogleGenerativeAI, HarmCategory, HarmBlockThreshold } = require("@google/generative-ai");

const GOOGLE_API_KEY = process.env.GOOGLE_API_KEY;
let genAI;
let textModel;

if (GOOGLE_API_KEY) {
  try {
    genAI = new GoogleGenerativeAI(GOOGLE_API_KEY);
    textModel = genAI.getGenerativeModel({ model: "gemini-1.5-flash-latest" });
    console.log("Google Generative AI SDK initialized successfully with gemini-1.5-flash-latest.");
  } catch (error) {
    console.error("FATAL: Failed to initialize Google Generative AI SDK:", error.message);
  }
} else {
  console.warn("Warning: GOOGLE_API_KEY is not defined. Google AI features will be disabled.");
}

const mapReadingLevelToPromptDescription = (readingLevel) => {
  switch (readingLevel) {
    case 'basic': return 'an easy-to-understand';
    case 'intermediate': return 'a moderately detailed';
    case 'advanced': return 'an advanced and comprehensive';
    default: return 'an easy-to-understand';
  }
};
const mapReadingLevelToCacheKey = (readingLevel) => {
  switch (readingLevel) {
    case 'basic': return 'easy';
    case 'intermediate': return 'moderate';
    case 'advanced': return 'advanced';
    default: return 'easy';
  }
};

const createContent = async (req, res) => {
  try {
    const { topic, originalText, tags, imageUrls, videoExplainers, audioNarrations } = req.body;
    if (!topic || !originalText) {
      return res.status(400).json({ error: 'Topic and originalText are required.' });
    }
    const topicSlug = topic.toLowerCase().trim().replace(/\s+/g, '-');
    const existingContent = await Content.findOne({ topic: topicSlug });
    if (existingContent) {
      return res.status(400).json({ error: `Content for topic "${topic}" already exists (slug: ${topicSlug}).` });
    }
    const newContent = new Content({
      topic: topicSlug,
      originalText,
      tags: tags || [],
      media: { imageUrls: imageUrls || [] },
      videoExplainers: videoExplainers || [],
      audioNarrations: audioNarrations || [],
      createdBy: req.user?._id
    });
    await newContent.save();
    res.status(201).json(newContent);
  } catch (err) {
    console.error("Error creating content:", err.message, err.stack);
    res.status(500).json({ error: 'Failed to create content' });
  }
};

const getAllContent = async (req, res) => {
  try {
    const contents = await Content.find().select('topic tags createdAt').sort({ createdAt: -1 });
    res.json(contents);
  } catch (err) {
    console.error("Error fetching all content:", err.message, err.stack);
    res.status(500).json({ error: 'Failed to retrieve content list' });
  }
};

const getContentById = async (req, res) => {
    try {
        const content = await Content.findById(req.params.id).populate('createdBy', 'name email');
        if (!content) {
            return res.status(404).json({ message: 'Content not found.' });
        }
        res.json(content);
    } catch (err) {
        console.error("Error fetching content by ID:", err.message, err.stack);
        if (err.kind === 'ObjectId') {
             return res.status(400).json({ message: 'Invalid content ID format.' });
        }
        res.status(500).json({ error: 'Failed to retrieve content' });
    }
};

const updateContent = async (req, res) => {
  try {
    const { topic, originalText, tags, imageUrls, videoExplainers, audioNarrations, simplifiedVersions, visualMaps } = req.body;
    const contentId = req.params.id;
    let content = await Content.findById(contentId);
    if (!content) {
      return res.status(404).json({ error: 'Content not found.' });
    }
    if (topic) content.topic = topic.toLowerCase().trim().replace(/\s+/g, '-');
    if (originalText) content.originalText = originalText;
    if (tags !== undefined) content.tags = tags;
    if (imageUrls !== undefined) content.media.imageUrls = imageUrls;
    if (videoExplainers !== undefined) content.videoExplainers = videoExplainers;
    if (audioNarrations !== undefined) content.audioNarrations = audioNarrations;
    if (simplifiedVersions !== undefined) content.simplifiedVersions = simplifiedVersions;
    if (visualMaps !== undefined) content.visualMaps = visualMaps;
    content.lastUpdatedBy = req.user?._id;
    const updatedContent = await content.save();
    res.json(updatedContent);
  } catch (err) {
    console.error("Error updating content:", err.message, err.stack);
    if (err.kind === 'ObjectId') { return res.status(400).json({ message: 'Invalid content ID format.' }); }
    res.status(500).json({ error: 'Failed to update content' });
  }
};

const deleteContent = async (req, res) => {
  try {
    const contentId = req.params.id;
    const content = await Content.findById(contentId);
    if (!content) { return res.status(404).json({ error: 'Content not found.' }); }
    await content.deleteOne();
    res.json({ message: 'Content removed successfully.' });
  } catch (err) {
    console.error("Error deleting content:", err.message, err.stack);
    if (err.kind === 'ObjectId') { return res.status(400).json({ message: 'Invalid content ID format.' });}
    res.status(500).json({ error: 'Failed to delete content' });
  }
};

const getContentByTopic = async (req, res) => {
    try {
        const topicSlug = req.params.topic.toLowerCase().trim();
        const user = req.user ? await User.findById(req.user.id).select('preferences') : null;
        const content = await Content.findOne({ topic: topicSlug }).populate('createdBy', 'name');
        if (!content) { return res.status(404).json({ message: `Content not found for topic: ${topicSlug}` });}
        let responseContent = { ...content.toObject() };
        if (user?.preferences?.readingLevel) {
            const cacheLevelKey = mapReadingLevelToCacheKey(user.preferences.readingLevel);
            const preferredSimplifiedVersion = content.simplifiedVersions.find(v => v.level === cacheLevelKey);
            if (preferredSimplifiedVersion) {
                responseContent.defaultSimplifiedText = preferredSimplifiedVersion.text;
                responseContent.defaultSimplifiedLevel = preferredSimplifiedVersion.level;
            }
        }
        res.json(responseContent);
    } catch (err) {
        console.error("Error fetching content by topic:", err.message, err.stack);
        res.status(500).json({ error: 'Failed to retrieve content' });
    }
};

const simplifyContent = async (req, res) => {
  if (!GOOGLE_API_KEY || !textModel) {
    console.error("Google AI SDK (textModel) not initialized for simplifyContent.");
    return res.status(500).json({ error: "AI service is not configured." });
  }
  try {
    const { topic: topicSlug } = req.body;
    let { level: clientRequestedLevel } = req.body;
    if (!topicSlug) { return res.status(400).json({ error: "Topic slug is required." }); }

    let promptLevelDescription;
    let cacheLevelKey;
    if (!clientRequestedLevel) {
      const userId = req.user?._id;
      let userReadingLevelPref = 'basic';
      if (userId) {
        const user = await User.findById(userId).select('preferences');
        if (user?.preferences?.readingLevel) userReadingLevelPref = user.preferences.readingLevel;
      }
      promptLevelDescription = mapReadingLevelToPromptDescription(userReadingLevelPref);
      cacheLevelKey = mapReadingLevelToCacheKey(userReadingLevelPref);
    } else {
      promptLevelDescription = mapReadingLevelToPromptDescription(clientRequestedLevel);
      cacheLevelKey = mapReadingLevelToCacheKey(clientRequestedLevel);
    }

    let contentDoc = await Content.findOne({ topic: topicSlug.toLowerCase().trim() });
    if (!contentDoc) { return res.status(404).json({ error: `Content for topic "${topicSlug}" not found.` });}

    const existingSimplified = contentDoc.simplifiedVersions.find(v => v.level === cacheLevelKey);
    if (existingSimplified) {
      return res.json({ simplifiedText: existingSimplified.text, level: cacheLevelKey });
    }

    console.log(`Generating new simplified version (Gemini) for: ${contentDoc.topic}, prompt level: "${promptLevelDescription}"`);
    const simplificationPrompt = `You are an expert tutor... [Your full simplification prompt here, same as before] ... Original Text:\n---\n${contentDoc.originalText}\n---\n\nSimplified Text (for ${promptLevelDescription} understanding):`;
    const safetySettings = [ /* ... */ { category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE }, { category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE }, { category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE }, { category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE }, ];
    const generationConfig = { /* ... */ };
    const result = await textModel.generateContent({ contents: [{ role: "user", parts: [{ text: simplificationPrompt }] }], generationConfig, safetySettings });
    const response = result.response;

    if (!response || !response.candidates || response.candidates.length === 0 || !response.candidates[0].content?.parts) {
        // ... [Same detailed error handling for Gemini response as before] ...
        const blockReason = response?.promptFeedback?.blockReason || response?.candidates?.[0]?.finishReason;
        console.error("Content generation issue with Google Gemini (simplify):", { blockReason, fullResponse: JSON.stringify(response, null, 2) });
        let userMessage = 'AI failed to generate simplified content.';
        if (blockReason === "SAFETY" || response?.candidates?.[0]?.finishReason === "SAFETY") { userMessage = 'Content could not be simplified due to safety filters.';}
        else if (blockReason) { userMessage = `Content generation blocked: ${blockReason}.`;}
        return res.status(400).json({ error: userMessage });
    }
    const simplifiedText = response.candidates[0].content.parts.map(part => part.text).join("").trim();
    contentDoc.simplifiedVersions.push({ level: cacheLevelKey, text: simplifiedText, createdAt: new Date() });
    if (req.user?._id) contentDoc.lastUpdatedBy = req.user._id;
    await contentDoc.save();
    res.json({ simplifiedText, level: cacheLevelKey });
  } catch (err) {
    // ... [Same detailed error handling for Gemini API calls as before] ...
    console.error("Error in simplifyContent (Google Gemini):", err.message, err.stack);
    let userMessage = 'Failed to simplify content using Google AI.';
    if (err.message.toLowerCase().includes("api key") || err.message.toLowerCase().includes("permission denied")) { userMessage = "Google AI API key is invalid or not authorized."; return res.status(401).json({ error: userMessage });}
    if (err.message.toLowerCase().includes("quota") || err.message.toLowerCase().includes("rate limit")) { userMessage = "Google AI API quota exceeded."; return res.status(429).json({ error: userMessage });}
    res.status(500).json({ error: userMessage });
  }
};

// --- UPDATED generateVisualMap with new prompt ---
const generateVisualMap = async (req, res) => {
  if (!GOOGLE_API_KEY || !textModel) {
    console.error("Google AI SDK (textModel) not initialized for generateVisualMap.");
    return res.status(500).json({ error: "AI service is not configured." });
  }
  try {
    const { topic: topicSlug, format = 'mermaid' } = req.body;
    if (!topicSlug) { return res.status(400).json({ error: "Topic slug is required." }); }
    if (format !== 'mermaid') { return res.status(400).json({ error: "Only 'mermaid' format supported."}); }

    let contentDoc = await Content.findOne({ topic: topicSlug.toLowerCase().trim() });
    if (!contentDoc) { return res.status(404).json({ error: `Content for topic "${topicSlug}" not found.`});}

    const existingMap = contentDoc.visualMaps?.find(v => v.format === format);
    if (existingMap) { return res.json({ visualMap: existingMap }); }

    console.log(`Generating new visual map (Gemini) for: ${contentDoc.topic}, format: ${format}`);

    // ***** THIS IS THE CRUCIAL PROMPT UPDATE *****
    const visualMapPrompt = `
      You are an expert in creating educational diagrams.
      From the following educational text about "${contentDoc.topic.replace(/-/g, ' ')}", generate **valid MermaidJS mindmap syntax**.
      The mindmap should clearly represent the key concepts and their hierarchical relationships as described in the text.
      - The main topic, "${contentDoc.topic.replace(/-/g, ' ')}", should be the root node, styled like this: root((Main Topic)).
      - Use **indentation** to define parent-child relationships. Each level of indentation creates a new sub-level in the mindmap.
      - Do NOT use any custom keywords like "sub(...)" or "end". Only use standard Mermaid mindmap indentation.

      Here is an example of the correct Mermaid mindmap syntax structure:
      mindmap
        root((Example Main Topic))
          Level 1 Child A
            Level 2 Grandchild A.1
            Level 2 Grandchild A.2
          Level 1 Child B
            Level 2 Grandchild B.1
          Another Level 1 Child

      The output should ONLY be the MermaidJS code block itself, starting with the word "mindmap". Do not include any other explanatory text, markdown formatting (like \`\`\`mermaid or \`\`\`), or any words before or after the MermaidJS code. Just the pure MermaidJS syntax.

      Original Text (excerpt):
      ---
      ${contentDoc.originalText.substring(0, 3500)} 
      ---

      MermaidJS Mindmap Code:
    `;
    // **********************************************

    const safetySettings = [ /* ... */ { category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE }, { category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE }, { category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE }, { category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE }, ];
    const generationConfig = { temperature: 0.1, maxOutputTokens: 1500 }; // Low temp for structured output
    const result = await textModel.generateContent({ contents: [{ role: "user", parts: [{ text: visualMapPrompt }] }], generationConfig, safetySettings });
    const response = result.response;

    if (!response || !response.candidates || response.candidates.length === 0 || !response.candidates[0].content?.parts) {
        // ... [Same detailed error handling for Gemini response as before] ...
        const blockReason = response?.promptFeedback?.blockReason || response?.candidates?.[0]?.finishReason;
        console.error("Visual map generation issue with Google Gemini:", { blockReason, fullResponse: JSON.stringify(response, null, 2) });
        let userMessage = 'AI failed to generate visual map.';
        if (blockReason === "SAFETY" || response?.candidates?.[0]?.finishReason === "SAFETY") { userMessage = 'Visual map could not be generated due to safety filters.';}
        else if (blockReason) { userMessage = `Visual map generation blocked: ${blockReason}.`;}
        return res.status(400).json({ error: userMessage });
    }
    let mermaidData = response.candidates[0].content.parts.map(part => part.text).join("").trim();
    // Clean potential markdown backticks
    mermaidData = mermaidData.replace(/^```mermaid\s*\n?([\s\S]*?)\n?```$/, '$1').trim();
    mermaidData = mermaidData.replace(/^```\s*\n?([\s\S]*?)\n?```$/, '$1').trim();

    console.log("[Controller] Gemini produced Mermaid data:", mermaidData.substring(0, 200) + "..."); // Log what Gemini returned

    const newVisualMap = { format, data: mermaidData, createdAt: new Date(), notes: "AI-Generated (Gemini)" };
    contentDoc.visualMaps.push(newVisualMap);
    if (req.user?._id) contentDoc.lastUpdatedBy = req.user._id;
    await contentDoc.save();
    res.json({ visualMap: newVisualMap });
  } catch (err) {
    // ... [Same detailed error handling for Gemini API calls as before] ...
    console.error("Error in generateVisualMap (Google Gemini):", err.message, err.stack);
    let userMessage = 'Failed to generate visual map using Google AI.';
    if (err.message.toLowerCase().includes("api key") || err.message.toLowerCase().includes("permission denied")) { userMessage = "Google AI API key is invalid or not authorized."; return res.status(401).json({ error: userMessage });}
    if (err.message.toLowerCase().includes("quota") || err.message.toLowerCase().includes("rate limit")) { userMessage = "Google AI API quota exceeded."; return res.status(429).json({ error: userMessage });}
    res.status(500).json({ error: userMessage });
  }
};

const generateAudioNarration = async (req, res) => {
    res.status(501).json({ error: "Audio narration not implemented." });
};
const findVideoExplainers = async (req, res) => {
  res.status(501).json({ error: "Video explainer sourcing not implemented." });
};

module.exports = {
  createContent,
  getAllContent,
  getContentById,
  updateContent,
  deleteContent,
  getContentByTopic,
  simplifyContent,
  generateVisualMap,
  generateAudioNarration,
  findVideoExplainers,
};

===== File: /controllers/qaController.js =====
// ===== File: /controllers/qaController.js =====
const axios = require('axios');
const Session = require('../models/Session');
const Content = require('../models/Content');
const User = require('../models/User'); // To get user preferences

const OPENROUTER_API_KEY = process.env.OPENROUTER_API_KEY;
const OPENROUTER_DEFAULT_MODEL = process.env.OPENROUTER_DEFAULT_MODEL || 'mistralai/mistral-7b-instruct:free';
const YOUR_SITE_URL = process.env.YOUR_SITE_URL || 'http://localhost:3000';
const YOUR_SITE_NAME = process.env.YOUR_SITE_NAME || 'AccessibleLearningPortal';

// Helper to map user reading level to simplification level for context
const mapReadingLevelToSimplifyLevel = (readingLevel) => {
  switch (readingLevel) {
    case 'basic': return 'easy';
    case 'intermediate': case 'advanced': return 'moderate';
    default: return 'easy';
  }
};

exports.askQuestion = async (req, res) => {
  try {
    const { question, topic } = req.body;
    const userId = req.user._id;

    if (!question || !topic) {
      return res.status(400).json({ error: 'Question and topic are required.' });
    }

    const user = await User.findById(userId).select('preferences');
    const userReadingLevel = user?.preferences?.readingLevel || 'basic';
    const preferredSimplifyLevel = mapReadingLevelToSimplifyLevel(userReadingLevel);

    // 1. Fetch context based on the topic
    const content = await Content.findOne({ topic: topic.toLowerCase().trim() });
    let contextText = "General knowledge.";
    let contextUsed = 'general_knowledge';

    if (content) {
        // Prioritize using a simplified version matching user's preference if available
        const preferredSimplifiedVersion = content.simplifiedVersions.find(v => v.level === preferredSimplifyLevel);
        if (preferredSimplifiedVersion) {
            contextText = preferredSimplifiedVersion.text;
            contextUsed = `simplified_${preferredSimplifyLevel}`;
        } else {
            // Fallback to any 'easy' simplified version if preferred not found
            const easyVersion = content.simplifiedVersions.find(v => v.level === 'easy');
            if (easyVersion) {
                contextText = easyVersion.text;
                contextUsed = 'simplified_easy';
            } else {
                contextText = content.originalText; // Fallback to original if no suitable simplified version
                contextUsed = 'original';
            }
        }
    } else {
         console.warn(`Content not found for topic "${topic}" in QA, using general context.`);
    }

    // 2. Construct prompt for LLM, incorporating user preference for clarity
    let promptIntro = `You are a friendly, patient, and helpful tutor for a neurodivergent student. The student prefers explanations that are very clear, simple, and tailored for a '${userReadingLevel}' reading level.`;
    if (user?.preferences?.preferredContentMode === 'visual') {
        promptIntro += " The student sometimes benefits from analogies or visualizable descriptions if appropriate for the question."
    }

    const prompt = `${promptIntro}
Context on the topic "${topic}":
---
${contextText.substring(0, 2500)}
---
Based *primarily* on the provided context, answer the student's question. If the context is insufficient, you may use your general knowledge but state that you are doing so. If the question is completely outside the context and your general knowledge, clearly say you don't have the information.
Student's Question: "${question}"
Answer:`;

    // 3. Call OpenRouter API
    const response = await axios.post(
      'https://openrouter.ai/api/v1/chat/completions',
      {
        model: OPENROUTER_DEFAULT_MODEL,
        messages: [
          // System message sets the persona more broadly
          { role: 'system', content: `You are a friendly, patient, and helpful tutor for a neurodivergent student who needs clear and simple explanations. Adapt your language complexity to a '${userReadingLevel}' reading level.` },
          { role: 'user', content: prompt }
        ],
        // max_tokens: 200 // Optionally limit response length
      },
      {
        headers: {
          'Authorization': `Bearer ${OPENROUTER_API_KEY}`,
          'Content-Type': 'application/json',
          'HTTP-Referer': YOUR_SITE_URL,
          'X-Title': YOUR_SITE_NAME
        }
      }
    );

    if (!response.data || !response.data.choices || response.data.choices.length === 0 || !response.data.choices[0].message) {
        console.error("Invalid response structure from OpenRouter API:", response.data);
        throw new Error('Invalid response structure from OpenRouter API');
    }

    const answer = response.data.choices[0].message.content.trim();

    // 4. Log interaction
    await Session.findOneAndUpdate(
        { userId: userId },
        {
            $push: {
                interactions: {
                    question: question,
                    answer: answer,
                    topic: topic,
                    contextUsed: contextUsed // Log which context was used
                }
            },
            $setOnInsert: { createdAt: new Date() }
        },
        { upsert: true, new: true }
    );

    res.json({ answer });

  } catch (err) {
    console.error("Error in askQuestion:", err.response ? JSON.stringify(err.response.data, null, 2) : err.message, err.stack);
    res.status(500).json({ error: err.message || 'Failed to get answer' });
  }
};

===== File: /models/Content.js =====
const mongoose = require('mongoose');

const simplifiedSchema = new mongoose.Schema({
  level: { // 'easy', 'moderate' correspond to user reading levels
    type: String,
    enum: ['easy', 'moderate', 'advanced'], // 'visual' mode is handled differently
    required: true
  },
  text: { type: String },
  createdAt: { type: Date, default: Date.now }
}, { _id: false });

// Schema for visual map data (could be JSON, Mermaid syntax, etc.)
const visualMapSchema = new mongoose.Schema({
  format: { type: String, enum: ['mermaid', 'json_graph', 'text_outline'], default: 'text_outline' },
  data: { type: String, required: true }, // Stores the actual visual data string
  notes: String, // Optional notes about the visual map
  createdAt: { type: Date, default: Date.now }
}, { _id: false });


const contentSchema = new mongoose.Schema({
  topic: {
    type: String,
    required: true,
    unique: true,
    lowercase: true,
    trim: true
  },
  originalText: {
    type: String,
    required: true
  },
  // For 'text summary' and 'dyslexia-friendly font' (applied on frontend)
  simplifiedVersions: [simplifiedSchema],
  // For 'visual map (concept maps)'
  visualMaps: [visualMapSchema],
  // For 'audio narration' (could be URL to generated TTS or uploaded file)
  audioNarrations: [
    {
      language: { type: String, default: 'en-US' },
      voice: { type: String, default: 'default' }, // Could specify voice model later
      url: { type: String, required: true },
      createdAt: { type: Date, default: Date.now }
    }
  ],
  // For 'video explainer (auto-generated or sourced)'
  videoExplainers: [
    {
      source: { type: String, enum: ['youtube', 'vimeo', 'custom_upload', 'generated'], default: 'youtube' },
      url: { type: String, required: true },
      title: String,
      description: String,
      createdAt: { type: Date, default: Date.now }
    }
  ],
  tags: [String],
  // This 'media' field might become redundant or used for other generic media
  // if specific types like audio/video are handled above.
  // For now, let's keep it for images or general files.
  media: {
    imageUrls: [String],
    // videoUrls: [String], // Moved to videoExplainers for more structure
  },
  createdBy: { // User who originally created/uploaded this content
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    // required: true // Make required if all content must be admin-added
  },
  lastUpdatedBy: { // User who last modified this content
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  createdAt: {
    type: Date,
    default: Date.now
  },
  updatedAt: {
    type: Date,
    default: Date.now
  }
});

// Update `updatedAt` timestamp before saving
contentSchema.pre('save', function(next) {
  if (this.isModified()) {
    this.updatedAt = Date.now();
  }
  next();
});

module.exports = mongoose.model('Content', contentSchema);

===== File: /models/Session.js =====
const mongoose = require('mongoose');

const sessionSchema = new mongoose.Schema({
  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  interactions: [
    {
      question: String,
      answer: String,
      topic: String, // Added topic field
      contextUsed: String, // e.g., 'original', 'simplified_easy', 'general_knowledge'
      timestamp: { type: Date, default: Date.now }
    }
  ],
  createdAt: { type: Date, default: Date.now }
});

module.exports = mongoose.model('Session', sessionSchema);

===== File: /models/User.js =====
// ===== File: /models/User.js =====
const mongoose = require('mongoose');
const bcrypt = require('bcrypt');

const userSchema = new mongoose.Schema({
  name: { type: String },
  email: { type: String, required: true, unique: true, lowercase: true, trim: true },
  password: { type: String, required: true },

  role: {
    type: String,
    enum: ['user', 'admin'],
    default: 'user'
  },

  preferences: {
    readingLevel: { type: String, default: 'basic', enum: ['basic', 'intermediate', 'advanced'] },
    fontSize: { type: String, default: 'medium', enum: ['small', 'medium', 'large', 'xlarge'] },
    theme: { type: String, default: 'light', enum: ['light', 'dark', 'high-contrast'] }, // Removed 'dyslexia' from here if it's a separate font toggle
    dyslexiaFontEnabled: { type: Boolean, default: false }, // NEW field for dyslexia font
    preferredContentMode: { type: String, default: 'text', enum: ['text', 'video', 'visual', 'audio']},
    ttsEnabled: { type: Boolean, default: false }
  },

  createdAt: { type: Date, default: Date.now }
});

// ... rest of the User model (pre-save hook, matchPassword method) ...
userSchema.pre('save', async function (next) {
  if (!this.isModified('password')) return next();
  const salt = await bcrypt.genSalt(10);
  this.password = await bcrypt.hash(this.password, salt);
  next();
});

userSchema.methods.matchPassword = async function (enteredPassword) {
  return await bcrypt.compare(enteredPassword, this.password);
};

module.exports = mongoose.model('User', userSchema);

===== File: /routes/authRoutes.js =====
const express = require('express');
const router = express.Router();
const { signup, login, getMe, updatePreferences, signupValidation, loginValidation } = require('../controllers/authController');
const { protect } = require('../middleware/authMiddleware');

router.post('/signup', signupValidation, signup);
router.post('/login', loginValidation, login);
router.get('/me', protect, getMe); // New route to get current user profile
router.put('/preferences', protect, updatePreferences); // New route to update preferences

module.exports = router;

===== File: /routes/contentRoutes.js =====
// ===== File: /server/routes/contentRoutes.js =====
const express = require('express');
const router = express.Router();
const contentController = require('../controllers/contentController');
const { protect, isAdmin } = require('../middleware/authMiddleware'); // Import isAdmin

// --- Routes for general users (protected) ---
router.get('/', protect, contentController.getAllContent);
router.get('/topic/:topic', protect, contentController.getContentByTopic);
router.post('/simplify', protect, contentController.simplifyContent);
router.post('/visual-map', protect, contentController.generateVisualMap);
// Add routes for audio/video generation/sourcing for users later if needed

// --- CRUD Routes for Content (Protected and Admin Only) ---
router.post('/create', protect, isAdmin, contentController.createContent);
router.get('/:id', protect, isAdmin, contentController.getContentById); // Admin can get by ID for management
router.put('/:id', protect, isAdmin, contentController.updateContent);
router.delete('/:id', protect, isAdmin, contentController.deleteContent);

// --- NEW: Routes for Audio/Video (Admin-focused initially) ---
router.post('/generate-audio', protect, isAdmin, contentController.generateAudioNarration);
router.post('/find-videos', protect, isAdmin, contentController.findVideoExplainers);


module.exports = router;

===== File: /routes/qaRoutes.js =====
// ===== File: /routes/qaRoutes.js =====
const express = require('express');
const router = express.Router();
const qaController = require('../controllers/qaController');
const { protect } = require('../middleware/authMiddleware'); // Import middleware

// POST a question - Requires user to be logged in
router.post('/ask', protect, qaController.askQuestion);

module.exports = router;

===== File: /app.js =====
const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const helmet = require('helmet'); // For security headers
const morgan = require('morgan'); // For request logging

require('dotenv').config();

// --- Environment Variable Check ---
const requiredEnvVars = [
  'MONGO_URI',
  'JWT_SECRET',
  'OPENROUTER_API_KEY',
  // 'YOUR_SITE_URL', // Recommended, but provide defaults in controllers if not set
  // 'YOUR_SITE_NAME', // Recommended, but provide defaults if not set
  // 'OPENROUTER_DEFAULT_MODEL' // Has a default in controllers
];
for (const envVar of requiredEnvVars) {
  if (!process.env[envVar]) {
    console.error(`FATAL ERROR: Environment variable ${envVar} is not defined.`);
    process.exit(1);
  }
}

const app = express();

// --- Middleware ---
const corsOptions = {
  origin: [ // Add your frontend URLs here
    "http://127.0.0.1:3000",
    "http://localhost:3000",
    "http://[::1]:3000",
    process.env.FRONTEND_URL, // If you have one in .env for deployed frontend
    "https://opulent-garbanzo-975vgqvp4jj4cg6x-3000.app.github.dev" // Example Codespaces URL
  ].filter(Boolean), // Filter out undefined/null values
  credentials: true,
  methods: "GET,HEAD,PUT,PATCH,POST,DELETE",
  preflightContinue: false,
  optionsSuccessStatus: 200
};
app.use(cors(corsOptions));
app.use(helmet()); // Adds various security HTTP headers
app.use(express.json({ limit: '10mb' })); // For parsing application/json, increased limit for potential media uploads
app.use(express.urlencoded({ extended: true, limit: '10mb' })); // For parsing application/x-www-form-urlencoded

if (process.env.NODE_ENV === 'development') {
  app.use(morgan('dev')); // HTTP request logger middleware (useful for development)
}

// --- Routes ---
const authRoutes = require('./routes/authRoutes');
const contentRoutes = require('./routes/contentRoutes');
const qaRoutes = require('./routes/qaRoutes');
// const userRoutes = require('./routes/userRoutes'); // If you create separate user management routes

app.use('/api/auth', authRoutes);
app.use('/api/content', contentRoutes);
app.use('/api/qa', qaRoutes);
// app.use('/api/users', userRoutes);


// --- Database Connection ---
mongoose.connect(process.env.MONGO_URI)
  .then(() => console.log("MongoDB connected successfully."))
  .catch(err => {
    console.error("MongoDB connection error:", err.message);
    process.exit(1); // Exit if DB connection fails
  });

// --- Basic Welcome Route ---
app.get("/", (req, res) => res.send("Accessible Learning Portal API is running."));

// --- Global Error Handler (simple example) ---
// This should be the last middleware
app.use((err, req, res, next) => {
  console.error("Unhandled error:", err.stack);
  res.status(err.status || 500).json({
    error: err.message || 'An unexpected error occurred.',
    // stack: process.env.NODE_ENV === 'development' ? err.stack : undefined // Optionally show stack in dev
  });
});


const PORT = process.env.PORT || 5000;
app.listen(PORT, () => console.log(`Server running on port ${PORT} in ${process.env.NODE_ENV || 'development'} mode.`));