
===== File: /utils/auditLogger.js =====
// ===== File: /utils/auditLogger.js =====
const AuditLog = require('../models/AuditLog');

const logAction = async (userId, action, entity, entityId = null, details = {}, ipAddress = null) => {
  try {
    const log = new AuditLog({
      user: userId,
      action,
      entity,
      entityId,
      details,
      ipAddress 
    });
    await log.save();
    // console.log('Audit log created:', action, entity, entityId); 
  } catch (error) {
    console.error('Failed to create audit log:', error.message, error.stack);
  }
};

module.exports = logAction;

===== File: /utils/generateToken.js =====
// ===== File: /utils/generateToken.js =====
const jwt = require('jsonwebtoken');

const generateToken = (id) => {
  // Check if JWT_SECRET is set
  if (!process.env.JWT_SECRET) {
      // Throw an error instead of exiting, so it can be caught by a global error handler or at startup
      throw new Error('FATAL ERROR: JWT_SECRET is not defined in .env file.');
  }

  return jwt.sign({ id }, process.env.JWT_SECRET, {
    expiresIn: '30d', // Token expires in 30 days (adjust as needed)
  });
};

module.exports = generateToken;

===== File: /middleware/authMiddleware.js =====
// ===== File: /middleware/authMiddleware.js =====
const jwt = require('jsonwebtoken');
const User = require('../models/User'); // Adjust path as per your project structure

const protect = async (req, res, next) => {
  let token;

  if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {
    try {
      token = req.headers.authorization.split(' ')[1];
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      req.user = await User.findById(decoded.id).select('-password');

      if (!req.user) {
        return res.status(401).json({ error: 'Not authorized, user not found' });
      }
      next();
    } catch (error) {
      console.error('Token verification failed:', error.message);
      if (error.name === 'JsonWebTokenError') {
        return res.status(401).json({ error: 'Not authorized, token failed (invalid signature)' });
      }
      if (error.name === 'TokenExpiredError') {
        return res.status(401).json({ error: 'Not authorized, token expired' });
      }
      return res.status(401).json({ error: 'Not authorized, token failed' });
    }
  }

  if (!token) {
    return res.status(401).json({ error: 'Not authorized, no token' });
  }
};

const isAdmin = (req, res, next) => {
  if (req.user && req.user.role === 'admin') {
    next();
  } else {
    res.status(403).json({ error: 'Not authorized as an admin' });
  }
};

const isCreator = (req, res, next) => {
  if (req.user && req.user.role === 'creator') {
    next();
  } else {
    res.status(403).json({ error: 'Not authorized as a creator' });
  }
};

const isCreatorOrAdmin = (req, res, next) => {
  if (req.user && (req.user.role === 'admin' || req.user.role === 'creator')) {
    next();
  } else {
    res.status(403).json({ error: 'Not authorized as an admin or creator' });
  }
};

module.exports = { protect, isAdmin, isCreator, isCreatorOrAdmin };

===== File: /controllers/authController.js =====
const User = require('../models/User');
const generateToken = require('../utils/generateToken');
const { validationResult } = require('express-validator'); // For input validation

// Validation rules (can be moved to a separate validation file later)
const { body } = require('express-validator');

exports.signupValidation = [
  body('name').optional().trim().isLength({ min: 2 }).withMessage('Name must be at least 2 characters'),
  body('email').isEmail().withMessage('Please provide a valid email').normalizeEmail(),
  body('password').isLength({ min: 6 }).withMessage('Password must be at least 6 characters')
];

exports.loginValidation = [
  body('email').isEmail().withMessage('Please provide a valid email').normalizeEmail(),
  body('password').exists().withMessage('Password is required')
];


exports.signup = async (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }

  try {
    const { name, email, password } = req.body;

    const existingUser = await User.findOne({ email: email.toLowerCase() });
    if (existingUser) return res.status(400).json({ error: 'User already exists' });

    const user = await User.create({ name, email, password });

    res.status(201).json({
      _id: user._id,
      name: user.name,
      email: user.email,
      preferences: user.preferences,
      token: generateToken(user._id)
    });

  } catch (err) {
    console.error("Signup error:", err);
    res.status(500).json({ error: err.message || 'Server error during signup' });
  }
};

exports.login = async (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }

  try {
    const { email, password } = req.body;

    const user = await User.findOne({ email: email.toLowerCase() });
    if (!user || !(await user.matchPassword(password))) {
      return res.status(401).json({ error: 'Invalid email or password' });
    }

    res.json({
      _id: user._id,
      name: user.name,
      email: user.email,
      role: user.role,
      preferences: user.preferences,
      token: generateToken(user._id)
    });

  } catch (err) {
    console.error("Login error:", err);
    res.status(500).json({ error: err.message || 'Server error during login' });
  }
};

// Get current logged-in user's profile
exports.getMe = async (req, res) => {
    try {
        // req.user is populated by the 'protect' middleware
        const user = await User.findById(req.user.id).select('-password');
        if (!user) {
            return res.status(404).json({ error: 'User not found' });
        }
        res.json({
            _id: user._id,
            name: user.name,
            email: user.email,
            role: user.role,
            preferences: user.preferences,
            createdAt: user.createdAt
        });
    } catch (err) {
        console.error("GetMe error:", err);
        res.status(500).json({ error: 'Server error fetching user profile' });
    }
};

// Update user preferences
exports.updatePreferences = async (req, res) => {
    try {
        const userId = req.user.id;
        // Destructure all expected preference fields
        const {
            readingLevel,
            fontSize,
            theme,
            dyslexiaFontEnabled, // Added
            preferredContentMode,
            ttsEnabled
        } = req.body;

        const user = await User.findById(userId);
        if (!user) {
            return res.status(404).json({ error: 'User not found' });
        }

        // Validate and update preferences
        if (readingLevel && ['basic', 'intermediate', 'advanced'].includes(readingLevel)) {
            user.preferences.readingLevel = readingLevel;
        }
        if (fontSize && ['small', 'medium', 'large', 'xlarge'].includes(fontSize)) {
            user.preferences.fontSize = fontSize;
        }
        if (theme && ['light', 'dark', 'high-contrast'].includes(theme)) {
            user.preferences.theme = theme;
        }
        if (typeof dyslexiaFontEnabled === 'boolean') { // Added
            user.preferences.dyslexiaFontEnabled = dyslexiaFontEnabled;
        }
        if (preferredContentMode && ['text', 'video', 'visual', 'audio'].includes(preferredContentMode)) {
            user.preferences.preferredContentMode = preferredContentMode;
        }
        if (typeof ttsEnabled === 'boolean') {
            user.preferences.ttsEnabled = ttsEnabled;
        }

        await user.save();
        res.json({
            message: 'Preferences updated successfully',
            preferences: user.preferences // Send back the full updated preferences object
        });

    } catch (err) {
        console.error("UpdatePreferences error:", err);
        res.status(500).json({ error: 'Server error updating preferences' });
    }
};

===== File: /controllers/contentController.js =====
// ===== File: /controllers/contentController.js =====
const Content = require('../models/Content');
const User = require('../models/User');
const UserLearningProgress = require('../models/UserLearningProgress');
const { GoogleGenerativeAI, HarmCategory, HarmBlockThreshold } = require("@google/generative-ai");
const logAction = require('../utils/auditLogger');
const crypto = require('crypto');
const mongoose = require('mongoose');

const GOOGLE_API_KEY = process.env.GOOGLE_API_KEY;
let genAI;
let textModel;

if (GOOGLE_API_KEY) {
  try {
    genAI = new GoogleGenerativeAI(GOOGLE_API_KEY);
    textModel = genAI.getGenerativeModel({ model: "gemini-1.5-flash-latest" });
    console.log("Google Generative AI SDK initialized successfully with gemini-1.5-flash-latest.");
  } catch (error) {
    console.error("FATAL: Failed to initialize Google Generative AI SDK:", error.message);
    // Not exiting process here, but features will be disabled.
  }
} else {
  console.warn("Warning: GOOGLE_API_KEY is not defined. Google AI features will be disabled.");
}

const mapReadingLevelToPromptDescription = (readingLevel) => {
  switch (readingLevel?.toLowerCase()) {
    case 'eli5': return 'extremely simple, explain-like-I\'m-5';
    case 'basic': case 'easy': return 'an easy-to-understand';
    case 'intermediate': case 'moderate': return 'a moderately detailed';
    case 'advanced': return 'an advanced and comprehensive';
    case 'high_school': return 'a high-school student level';
    case 'college_intro': return 'a college introductory level';
    default: return 'an easy-to-understand';
  }
};

const mapReadingLevelToCacheKey = (readingLevel) => {
  switch (readingLevel?.toLowerCase()) {
    case 'eli5': return 'eli5';
    case 'basic': case 'easy': return 'easy';
    case 'intermediate': case 'moderate': return 'moderate';
    case 'advanced': return 'advanced';
    case 'high_school': return 'high_school';
    case 'college_intro': return 'college_intro';
    default: return 'easy';
  }
};

const createContent = async (req, res) => {
  try {
    const { topic, originalText, tags, imageUrls, videoExplainers, audioNarrations, learningObjectives, keyVocabulary } = req.body;
    if (!topic || !originalText) {
      return res.status(400).json({ error: 'Topic and originalText are required.' });
    }
    const topicSlug = topic.toLowerCase().trim().replace(/\s+/g, '-').replace(/[^\w-]+/g, '');
    const existingContent = await Content.findOne({ topic: topicSlug });
    if (existingContent) {
      return res.status(400).json({ error: `Content for topic "${topic}" already exists (slug: ${topicSlug}).` });
    }
    const newContent = new Content({
      topic: topicSlug,
      originalText,
      tags: tags || [],
      media: { imageUrls: imageUrls || [] },
      videoExplainers: videoExplainers || [],
      audioNarrations: audioNarrations || [],
      learningObjectives: learningObjectives || [],
      keyVocabulary: keyVocabulary || [],
      createdBy: req.user._id
    });
    await newContent.save();

    await logAction(
      req.user.id,
      'CREATE_CONTENT',
      'Content',
      newContent._id,
      {
        topicSlug: newContent.topic,
        titleFromUser: topic,
        tags: newContent.tags,
        charCount: originalText.length,
        hasLearningObjectives: (learningObjectives && learningObjectives.length > 0),
        hasKeyVocabulary: (keyVocabulary && keyVocabulary.length > 0),
      },
      req.ip
    );

    const populatedContent = await Content.findById(newContent._id)
                                     .populate('createdBy', 'name email')
                                     .populate('lastUpdatedBy', 'name email');
    res.status(201).json(populatedContent);
  } catch (err) {
    console.error("Error creating content:", err.message, err.stack);
    res.status(500).json({ error: 'Failed to create content' });
  }
};

const getAllContent = async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 10;
    const skip = (page - 1) * limit;

    const query = {};
    if (req.query.search && req.query.search.trim() !== '') {
      const searchRegex = new RegExp(req.query.search.trim(), 'i');
      query.$or = [
        { topic: searchRegex },
        { originalText: searchRegex },
        { tags: searchRegex },
        { learningObjectives: searchRegex },
        { keyVocabulary: searchRegex }
      ];
    }
    if (req.query.tag && req.query.tag.trim() !== '') {
        query.tags = { $regex: new RegExp(`^${req.query.tag.trim()}$`, 'i') };
    }
    if (req.query.creatorId) {
        query.createdBy = req.query.creatorId;
    }

    const sortOptions = {};
    if (req.query.sortBy) {
      const parts = req.query.sortBy.split(':');
      sortOptions[parts[0]] = parts[1] === 'desc' ? -1 : 1;
    } else {
      sortOptions.createdAt = -1;
    }

    const contents = await Content.find(query)
      .populate('createdBy', 'name email')
      .populate('lastUpdatedBy', 'name email')
      .sort(sortOptions)
      .skip(skip)
      .limit(limit)
      .select('topic tags originalText createdAt createdBy lastUpdatedBy updatedAt learningObjectives keyVocabulary');

    const totalContents = await Content.countDocuments(query);
    const totalPages = Math.ceil(totalContents / limit);

    res.json({
      contents,
      currentPage: page,
      totalPages,
      totalContents,
    });
  } catch (err) {
    console.error("Error fetching all content:", err.message, err.stack);
    res.status(500).json({ error: 'Failed to retrieve content list' });
  }
};

const getContentById = async (req, res) => {
    try {
        if (!mongoose.Types.ObjectId.isValid(req.params.id)) {
            return res.status(400).json({ message: 'Invalid content ID format.' });
        }
        const content = await Content.findById(req.params.id)
            .populate('createdBy', 'name email')
            .populate('lastUpdatedBy', 'name email');
        if (!content) {
            return res.status(404).json({ message: 'Content not found.' });
        }
        res.json(content);
    } catch (err) {
        console.error("Error fetching content by ID:", err.message, err.stack);
        res.status(500).json({ error: 'Failed to retrieve content' });
    }
};

const updateContent = async (req, res) => {
  try {
    const { topic, originalText, tags, imageUrls, videoExplainers, audioNarrations, learningObjectives, keyVocabulary } = req.body;
    const contentId = req.params.id;

    if (!mongoose.Types.ObjectId.isValid(contentId)) {
        return res.status(400).json({ message: 'Invalid content ID format.' });
    }
    let content = await Content.findById(contentId);
    if (!content) {
      return res.status(404).json({ error: 'Content not found.' });
    }

    const changes = {};

    const newSlug = topic ? topic.toLowerCase().trim().replace(/\s+/g, '-').replace(/[^\w-]+/g, '') : content.topic;
    if (topic && content.topic !== newSlug) {
        changes.topic = { old: content.topic, new: newSlug };
        content.topic = newSlug;
    }
    if (originalText !== undefined && content.originalText !== originalText) {
        changes.originalText = "modified";
        content.originalText = originalText;
    }
    if (tags !== undefined && JSON.stringify(content.tags.slice().sort()) !== JSON.stringify(tags.slice().sort())) {
        changes.tags = { old: content.tags, new: tags };
        content.tags = tags;
    }
    if (imageUrls !== undefined && JSON.stringify(content.media.imageUrls.slice().sort()) !== JSON.stringify(imageUrls.slice().sort())) {
        changes.imageUrls = "modified";
        content.media.imageUrls = imageUrls;
    }
    if (videoExplainers !== undefined && JSON.stringify(content.videoExplainers) !== JSON.stringify(videoExplainers)) {
        changes.videoExplainers = "modified";
        content.videoExplainers = videoExplainers;
    }
    if (audioNarrations !== undefined && JSON.stringify(content.audioNarrations) !== JSON.stringify(audioNarrations)) {
        changes.audioNarrations = "modified";
        content.audioNarrations = audioNarrations;
    }
    if (learningObjectives !== undefined && JSON.stringify(content.learningObjectives?.slice().sort() || []) !== JSON.stringify(learningObjectives.slice().sort())) {
        changes.learningObjectives = { old: content.learningObjectives, new: learningObjectives };
        content.learningObjectives = learningObjectives;
    }
    if (keyVocabulary !== undefined && JSON.stringify(content.keyVocabulary?.slice().sort() || []) !== JSON.stringify(keyVocabulary.slice().sort())) {
        changes.keyVocabulary = { old: content.keyVocabulary, new: keyVocabulary };
        content.keyVocabulary = keyVocabulary;
    }

    if (Object.keys(changes).length > 0) {
        content.lastUpdatedBy = req.user._id;
        // When critical fields like originalText change, it might be good to clear existing AI-generated versions
        // as they might become outdated. This is a design choice.
        // Example: If originalText changes, clear simplifiedVersions and visualMaps
        if (changes.originalText) {
            content.simplifiedVersions = [];
            content.visualMaps = [];
            changes.clearedAiVersions = true;
        }
    }

    const updatedContent = await content.save();

    if (Object.keys(changes).length > 0) {
        await logAction(
          req.user.id,
          'UPDATE_CONTENT',
          'Content',
          updatedContent._id,
          {
            topicSlug: updatedContent.topic,
            titleFromUser: topic,
            changes: changes,
          },
          req.ip
        );
    }

    const populatedContent = await Content.findById(updatedContent._id)
                                    .populate('createdBy', 'name email')
                                    .populate('lastUpdatedBy', 'name email');
    res.json(populatedContent);
  } catch (err) {
    console.error("Error updating content:", err.message, err.stack);
    res.status(500).json({ error: 'Failed to update content' });
  }
};

const deleteContent = async (req, res) => {
  try {
    const contentId = req.params.id;
    if (!mongoose.Types.ObjectId.isValid(contentId)) {
        return res.status(400).json({ message: 'Invalid content ID format.' });
    }
    const content = await Content.findById(contentId);
    if (!content) { return res.status(404).json({ error: 'Content not found.' }); }

    const deletedTopicSlug = content.topic;
    const deletedTitle = content.topic.replace(/-/g, ' ');
    await content.deleteOne();

    const progressDeletionResult = await UserLearningProgress.deleteMany({ contentId: contentId });

    await logAction(
      req.user.id,
      'DELETE_CONTENT',
      'Content',
      contentId, // Keep as ObjectId if schema expects it, or convert to string if necessary
      { topicSlug: deletedTopicSlug, title: deletedTitle, progressRecordsDeletedCount: progressDeletionResult.deletedCount },
      req.ip
    );
    res.json({ message: 'Content and associated learning progress removed successfully.' });
  } catch (err) {
    console.error("Error deleting content:", err.message, err.stack);
    res.status(500).json({ error: 'Failed to delete content' });
  }
};

const getContentByTopic = async (req, res) => {
    try {
        const topicSlug = req.params.topic.toLowerCase().trim();
        const user = req.user ? await User.findById(req.user.id).select('preferences') : null;

        const content = await Content.findOne({ topic: topicSlug })
                                .populate('createdBy', 'name email')
                                .populate('lastUpdatedBy', 'name email');

        if (!content) { return res.status(404).json({ message: `Content not found for topic: ${topicSlug}` });}

        let responseContent = { ...content.toObject() };
        let learningProgress = null;

        if (user) {
            learningProgress = await UserLearningProgress.findOne({ userId: user._id, contentId: content._id });
        }
        responseContent.learningProgress = learningProgress;

        // Determine default simplified text
        if (user?.preferences?.readingLevel || !responseContent.defaultSimplifiedText) {
            const preferredLevel = user?.preferences?.readingLevel || 'basic';
            const cacheLevelKey = mapReadingLevelToCacheKey(preferredLevel);
            const preferredSimplifiedVersion = content.simplifiedVersions.find(v => v.level === cacheLevelKey);

            if (preferredSimplifiedVersion) {
                responseContent.defaultSimplifiedText = preferredSimplifiedVersion.text;
                responseContent.defaultSimplifiedLevel = preferredSimplifiedVersion.level;
            } else if (content.simplifiedVersions && content.simplifiedVersions.length > 0) {
                responseContent.defaultSimplifiedText = content.simplifiedVersions[0].text;
                responseContent.defaultSimplifiedLevel = content.simplifiedVersions[0].level;
            }
        }
        res.json(responseContent);
    } catch (err) {
        console.error("Error fetching content by topic:", err.message, err.stack);
        res.status(500).json({ error: 'Failed to retrieve content' });
    }
};

const simplifyContent = async (req, res) => {
  if (!textModel) { // Check if textModel is initialized
    console.error("Google AI SDK (textModel) not initialized for simplifyContent.");
    return res.status(500).json({ error: "AI service is not configured or API key missing." });
  }
  try {
    const { topic: topicSlug, level: clientRequestedLevel } = req.body;
    if (!topicSlug) { return res.status(400).json({ error: "Topic slug is required." }); }

    let effectiveLevel = clientRequestedLevel;
    if (!effectiveLevel && req.user) {
      const user = await User.findById(req.user._id).select('preferences.readingLevel');
      effectiveLevel = user?.preferences?.readingLevel || 'basic';
    } else if (!effectiveLevel) {
        effectiveLevel = 'basic'; // Default if no user and no specific request
    }

    const promptLevelDescription = mapReadingLevelToPromptDescription(effectiveLevel);
    const cacheLevelKey = mapReadingLevelToCacheKey(effectiveLevel);

    let contentDoc = await Content.findOne({ topic: topicSlug.toLowerCase().trim() });
    if (!contentDoc) { return res.status(404).json({ error: `Content for topic "${topicSlug}" not found.` });}

    const existingSimplified = contentDoc.simplifiedVersions.find(v => v.level === cacheLevelKey);
    if (existingSimplified) {
      return res.json({ simplifiedText: existingSimplified.text, level: cacheLevelKey, topicId: contentDoc._id.toString() });
    }

    console.log(`Generating new simplified version (Gemini) for: ${contentDoc.topic}, prompt level: "${promptLevelDescription}", cache key: "${cacheLevelKey}"`);
    const simplificationPrompt = `You are an expert tutor specialized in adapting complex educational text for neurodivergent learners. Your goal is to simplify the following text while preserving its core meaning and accuracy. Adapt your language to suit a '${promptLevelDescription}' reading level. Use clear, concise sentences, and break down complex ideas into smaller, digestible parts. Avoid jargon where possible, or explain it simply if essential. If relevant, use analogies or simple examples. Ensure the tone is encouraging and supportive. Do NOT add any preambles like "Okay, here's the simplified version". Directly provide the simplified text. Original Text:\n---\n${contentDoc.originalText}\n---\n\nSimplified Text (for ${promptLevelDescription} understanding):`;
    const safetySettings = [ { category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE }, { category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE }, { category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE }, { category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE }, ];
    const generationConfig = { temperature: 0.3, maxOutputTokens: 2000 };

    const result = await textModel.generateContent({ contents: [{ role: "user", parts: [{ text: simplificationPrompt }] }], generationConfig, safetySettings });
    const response = result.response;

    if (!response || !response.candidates || response.candidates.length === 0 || !response.candidates[0].content?.parts) {
        const blockReason = response?.promptFeedback?.blockReason || response?.candidates?.[0]?.finishReason;
        console.error("Content generation issue with Google Gemini (simplify):", { blockReason, safetyRatings: response?.candidates?.[0]?.safetyRatings });
        let userMessage = 'AI failed to generate simplified content.';
        if (blockReason === "SAFETY" || response?.candidates?.[0]?.finishReason === "SAFETY") { userMessage = 'Content could not be simplified due to safety filters.';}
        else if (blockReason) { userMessage = `Content generation blocked: ${blockReason}.`;}
        return res.status(400).json({ error: userMessage });
    }
    const simplifiedText = response.candidates[0].content.parts.map(part => part.text).join("").trim();

    const alreadyExists = contentDoc.simplifiedVersions.some(v => v.level === cacheLevelKey && v.text === simplifiedText);
    if (!alreadyExists) {
        contentDoc.simplifiedVersions.push({ level: cacheLevelKey, text: simplifiedText, createdAt: new Date() });
        if (req.user) contentDoc.lastUpdatedBy = req.user._id;
        await contentDoc.save();
    }

    if (req.user) {
        await logAction(
            req.user.id,
            'GENERATE_SIMPLIFIED_CONTENT',
            'Content',
            contentDoc._id,
            { topic: contentDoc.topic, requestedLevel: clientRequestedLevel, effectiveLevel: effectiveLevel, cacheLevelKey: cacheLevelKey },
            req.ip
        );
    }

    res.json({ simplifiedText, level: cacheLevelKey, topicId: contentDoc._id.toString() });
  } catch (err) {
    console.error("Error in simplifyContent (Google Gemini):", err.message, err.stack);
    let userMessage = 'Failed to simplify content using Google AI.';
    if (err.message.toLowerCase().includes("api key") || err.message.toLowerCase().includes("permission denied")) { userMessage = "Google AI API key is invalid or not authorized."; return res.status(401).json({ error: userMessage });}
    if (err.message.toLowerCase().includes("quota") || err.message.toLowerCase().includes("rate limit")) { userMessage = "Google AI API quota exceeded."; return res.status(429).json({ error: userMessage });}
    res.status(500).json({ error: userMessage });
  }
};

const generateVisualMap = async (req, res) => {
  if (!textModel) {
    console.error("Google AI SDK (textModel) not initialized for generateVisualMap.");
    return res.status(500).json({ error: "AI service is not configured or API key missing." });
  }
  try {
    const { topic: topicSlug, format = 'mermaid' } = req.body;
    if (!topicSlug) { return res.status(400).json({ error: "Topic slug is required." }); }
    if (format !== 'mermaid') { return res.status(400).json({ error: "Only 'mermaid' format supported."}); }

    let contentDoc = await Content.findOne({ topic: topicSlug.toLowerCase().trim() });
    if (!contentDoc) { return res.status(404).json({ error: `Content for topic "${topicSlug}" not found.`});}

    const existingMap = contentDoc.visualMaps?.find(v => v.format === format);
    if (existingMap) { return res.json({ visualMap: existingMap, topicId: contentDoc._id.toString() }); }

    console.log(`Generating new visual map (Gemini) for: ${contentDoc.topic}, format: ${format}`);
    const visualMapPrompt = `
      You are an expert in creating educational diagrams.
      From the following educational text about "${contentDoc.topic.replace(/-/g, ' ')}", generate **valid MermaidJS mindmap syntax**.
      The mindmap should clearly represent the key concepts and their hierarchical relationships as described in the text.
      - The main topic, "${contentDoc.topic.replace(/-/g, ' ')}", should be the root node, styled like this: root((Main Topic)).
      - Use **indentation** to define parent-child relationships. Each level of indentation creates a new sub-level in the mindmap.
      - Do NOT use any custom keywords like "sub(...)" or "end". Only use standard Mermaid mindmap indentation.

      Here is an example of the correct Mermaid mindmap syntax structure:
      mindmap
        root((Example Main Topic))
          Level 1 Child A
            Level 2 Grandchild A.1
            Level 2 Grandchild A.2
          Level 1 Child B
            Level 2 Grandchild B.1
          Another Level 1 Child

      The output should ONLY be the MermaidJS code block itself, starting with the word "mindmap". Do not include any other explanatory text, markdown formatting (like \`\`\`mermaid or \`\`\`), or any words before or after the MermaidJS code. Just the pure MermaidJS syntax.

      Original Text (excerpt, max 3500 chars):
      ---
      ${contentDoc.originalText.substring(0, 3500)}
      ---

      MermaidJS Mindmap Code:
    `;
    const safetySettings = [ { category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE }, { category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE }, { category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE }, { category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE }, ];
    const generationConfig = { temperature: 0.1, maxOutputTokens: 1500 };
    const result = await textModel.generateContent({ contents: [{ role: "user", parts: [{ text: visualMapPrompt }] }], generationConfig, safetySettings });
    const response = result.response;

    if (!response || !response.candidates || response.candidates.length === 0 || !response.candidates[0].content?.parts) {
        const blockReason = response?.promptFeedback?.blockReason || response?.candidates?.[0]?.finishReason;
        console.error("Visual map generation issue with Google Gemini:", { blockReason, fullResponse: JSON.stringify(response, null, 2) });
        let userMessage = 'AI failed to generate visual map.';
        if (blockReason === "SAFETY" || response?.candidates?.[0]?.finishReason === "SAFETY") { userMessage = 'Visual map could not be generated due to safety filters.';}
        else if (blockReason) { userMessage = `Visual map generation blocked: ${blockReason}.`;}
        return res.status(400).json({ error: userMessage });
    }
    let mermaidData = response.candidates[0].content.parts.map(part => part.text).join("").trim();
    mermaidData = mermaidData.replace(/^```mermaid\s*\n?([\s\S]*?)\n?```$/, '$1').trim();
    mermaidData = mermaidData.replace(/^```\s*\n?([\s\S]*?)\n?```$/, '$1').trim();

    const newVisualMap = { format, data: mermaidData, createdAt: new Date(), notes: "AI-Generated (Gemini)" };
    contentDoc.visualMaps.push(newVisualMap);
    if (req.user) contentDoc.lastUpdatedBy = req.user._id;
    await contentDoc.save();

    if(req.user) {
        await logAction(
            req.user.id,
            'GENERATE_VISUAL_MAP',
            'Content',
            contentDoc._id,
            { topic: contentDoc.topic, format: format },
            req.ip
        );
    }

    res.json({ visualMap: newVisualMap, topicId: contentDoc._id.toString() });
  } catch (err) {
    console.error("Error in generateVisualMap (Google Gemini):", err.message, err.stack);
    let userMessage = 'Failed to generate visual map using Google AI.';
    if (err.message.toLowerCase().includes("api key") || err.message.toLowerCase().includes("permission denied")) { userMessage = "Google AI API key is invalid or not authorized."; return res.status(401).json({ error: userMessage });}
    if (err.message.toLowerCase().includes("quota") || err.message.toLowerCase().includes("rate limit")) { userMessage = "Google AI API quota exceeded."; return res.status(429).json({ error: userMessage });}
    res.status(500).json({ error: userMessage });
  }
};

const generateAudioNarration = async (req, res) => {
    const { contentId, textToNarrate } = req.body;
    if (!contentId || !textToNarrate) {
        return res.status(400).json({error: "Content ID and text are required."});
    }
    if (!mongoose.Types.ObjectId.isValid(contentId)) {
        return res.status(400).json({ error: 'Invalid content ID.' });
    }
     const content = await Content.findById(contentId);
     if (!content) {
        return res.status(404).json({error: "Content not found."});
     }

    const placeholderUrl = `https://example.com/audio/${contentId}-${Date.now()}.mp3`;
    const newNarration = {
        url: placeholderUrl,
        language: 'en-US',
        voice: 'default',
        createdAt: new Date()
    };
    content.audioNarrations.push(newNarration);
    if (req.user) content.lastUpdatedBy = req.user._id;
    await content.save();

    if(req.user) {
        await logAction(
            req.user.id,
            'GENERATE_AUDIO_NARRATION',
            'Content',
            contentId,
            { topic: content.topic, url: placeholderUrl, source: "placeholder_manual" }, // Updated source
            req.ip
        );
    }
    res.status(201).json({ message: "Audio narration URL placeholder created.", narration: newNarration, topicId: contentId.toString() });
};
const findVideoExplainers = async (req, res) => {
  res.status(501).json({ error: "Video explainer sourcing not implemented." });
};

module.exports = {
  createContent,
  getAllContent,
  getContentById,
  updateContent,
  deleteContent,
  getContentByTopic,
  simplifyContent,
  generateVisualMap,
  generateAudioNarration,
  findVideoExplainers,
};

===== File: /controllers/courseController.js =====
// ===== File: /controllers/courseController.js =====
const Course = require('../models/Course');
const Module = require('../models/Module');
const Lesson = require('../models/Lesson'); // For cascading deletes or operations
const User = require('../models/User');
const mongoose = require('mongoose');
const { validationResult, body } = require('express-validator');
const logAction = require('../utils/auditLogger');


exports.courseCreateValidation = [
    body('title').trim().isLength({ min: 3 }).withMessage('Course title must be at least 3 characters.'),
    body('description').optional().trim(),
    body('category').optional().trim(),
    body('coverImage').optional().isURL().withMessage('Invalid cover image URL.'),
    body('globalLearningObjectives').optional().isArray(),
    body('published').optional().isBoolean()
];

exports.createCourse = async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
    }

    try {
        const { title, description, category, coverImage, globalLearningObjectives, published } = req.body;
        const slug = title.toLowerCase().trim().replace(/\s+/g, '-').replace(/[^\w-]+/g, '');

        const existingCourse = await Course.findOne({ slug });
        if (existingCourse) {
            return res.status(400).json({ error: `Course with title "${title}" resulting in slug "${slug}" already exists.` });
        }

        const course = new Course({
            title,
            description,
            slug, // slug will be auto-generated by pre-save hook if not provided here explicitly
            category,
            coverImage,
            globalLearningObjectives: globalLearningObjectives || [],
            published: published || false,
            createdBy: req.user._id,
            instructorIds: [req.user._id] // Creator is initially an instructor
        });

        await course.save();

        await logAction(req.user.id, 'CREATE_COURSE', 'Course', course._id, { title: course.title, slug: course.slug }, req.ip);
        res.status(201).json(course);
    } catch (error) {
        console.error("Create Course Error:", error);
        res.status(500).json({ error: 'Failed to create course.' });
    }
};

exports.getAllCourses = async (req, res) => {
    try {
        // For admin/creator: list all courses for management
        // For students: list published courses they can enroll in (or are enrolled in)
        const query = {};
        if (req.user.role !== 'admin' && req.user.role !== 'creator') {
            query.published = true; // Students only see published courses
        }
        // Add pagination, search, filtering as needed, similar to contentController.getAllContent
        const courses = await Course.find(query)
            .populate('createdBy', 'name email')
            .populate('instructorIds', 'name email')
            .sort({ createdAt: -1 });
        res.json(courses);
    } catch (error) {
        console.error("Get All Courses Error:", error);
        res.status(500).json({ error: 'Failed to retrieve courses.' });
    }
};

exports.getCourseByIdOrSlug = async (req, res) => {
    try {
        const identifier = req.params.identifier;
        let course;

        if (mongoose.Types.ObjectId.isValid(identifier)) {
            course = await Course.findById(identifier);
        } else {
            course = await Course.findOne({ slug: identifier });
        }

        if (!course) {
            return res.status(404).json({ error: 'Course not found.' });
        }
        // Further populate modules and lessons if needed for detail view
        // Example: .populate({ path: 'modules', populate: { path: 'lessons' } })
        await course.populate([
            { path: 'createdBy', select: 'name email' },
            { path: 'instructorIds', select: 'name email' },
            {
                path: 'modules',
                options: { sort: { order: 1 } }, // Sort modules by order
                populate: {
                    path: 'lessons',
                    options: { sort: { order: 1 } }, // Sort lessons by order
                    populate: { // Populate items within lessons
                        path: 'items.itemId',
                        select: 'title topic originalText' // Select fields relevant for display
                    }
                }
            }
        ]);


        if (!course.published && (!req.user || (req.user.role !== 'admin' && req.user.role !== 'creator' && !course.instructorIds.map(id => id.toString()).includes(req.user._id.toString())))) {
             return res.status(403).json({ error: 'You are not authorized to view this unpublished course.' });
        }

        res.json(course);
    } catch (error) {
        console.error("Get Course By ID/Slug Error:", error);
        res.status(500).json({ error: 'Failed to retrieve course.' });
    }
};


exports.updateCourse = async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
    }
    try {
        const courseId = req.params.id;
        const { title, description, category, coverImage, globalLearningObjectives, published, instructorIds } = req.body;

        const course = await Course.findById(courseId);
        if (!course) {
            return res.status(404).json({ error: 'Course not found.' });
        }

        // Authorization: Only admin, creator, or instructor of the course can update
        if (req.user.role !== 'admin' && req.user.role !== 'creator' && !course.instructorIds.map(id => id.toString()).includes(req.user._id.toString())) {
            return res.status(403).json({ error: 'Not authorized to update this course.' });
        }
        
        const oldValues = {
            title: course.title,
            published: course.published,
        };

        if (title) {
            course.title = title;
            course.slug = title.toLowerCase().trim().replace(/\s+/g, '-').replace(/[^\w-]+/g, '');
            // Check if new slug conflicts (excluding current course)
            const conflictingCourse = await Course.findOne({ slug: course.slug, _id: { $ne: course._id } });
            if (conflictingCourse) {
                 return res.status(400).json({ error: `A course with the title "${title}" (slug: "${course.slug}") already exists.` });
            }
        }
        if (description !== undefined) course.description = description;
        if (category !== undefined) course.category = category;
        if (coverImage !== undefined) course.coverImage = coverImage;
        if (globalLearningObjectives !== undefined) course.globalLearningObjectives = globalLearningObjectives;
        if (published !== undefined) course.published = published;
        
        if (instructorIds && Array.isArray(instructorIds)) {
            // Validate instructorIds are valid user ObjectIds
            const validInstructors = await User.find({ _id: { $in: instructorIds }, role: { $in: ['admin', 'creator'] } }).select('_id');
            course.instructorIds = validInstructors.map(u => u._id);
        }

        course.lastUpdatedBy = req.user._id;
        await course.save();
        
        const changes = {};
        if(oldValues.title !== course.title) changes.title = {old: oldValues.title, new: course.title};
        if(oldValues.published !== course.published) changes.published = {old: oldValues.published, new: course.published};
        // Add more fields to changes if needed for audit log

        if (Object.keys(changes).length > 0) {
            await logAction(req.user.id, 'UPDATE_COURSE', 'Course', course._id, { changes }, req.ip);
        }
        res.json(course);
    } catch (error) {
        console.error("Update Course Error:", error);
        if (error.code === 11000) { // Duplicate key error for slug
            return res.status(400).json({ error: 'A course with this title or resulting slug already exists.' });
        }
        res.status(500).json({ error: 'Failed to update course.' });
    }
};

exports.deleteCourse = async (req, res) => {
    try {
        const courseId = req.params.id;
        const course = await Course.findById(courseId);
        if (!course) {
            return res.status(404).json({ error: 'Course not found.' });
        }

        // Authorization: Only admin or original creator (or specific high-level creator)
        if (req.user.role !== 'admin' && course.createdBy.toString() !== req.user._id.toString()) {
             return res.status(403).json({ error: 'Not authorized to delete this course.' });
        }
        
        const deletedTitle = course.title;

        // Potentially complex: Delete all associated modules, lessons, and lesson items (Content, Quizzes etc.)
        // This requires careful handling and could be resource-intensive.
        // For now, let's just delete the course. A more robust solution would handle children.
        // Example for children (use with caution, might need transactions for all-or-nothing):
        // await Module.deleteMany({ courseId: course._id }); // And then lessons for each module, etc.

        await course.deleteOne();

        await logAction(req.user.id, 'DELETE_COURSE', 'Course', courseId, { title: deletedTitle, slug: course.slug }, req.ip);
        res.json({ message: `Course "${deletedTitle}" deleted successfully.` });
    } catch (error) {
        console.error("Delete Course Error:", error);
        res.status(500).json({ error: 'Failed to delete course.' });
    }
};

// --- Student Enrollment ---
exports.enrollInCourse = async (req, res) => {
    try {
        const courseId = req.params.id;
        const userId = req.user._id;

        const course = await Course.findById(courseId);
        if (!course || !course.published) {
            return res.status(404).json({ error: 'Published course not found.' });
        }

        if (course.studentIds.map(id => id.toString()).includes(userId.toString())) {
            return res.status(400).json({ message: 'Already enrolled in this course.' });
        }

        course.studentIds.push(userId);
        await course.save();
        await logAction(req.user.id, 'ENROLL_COURSE', 'Course', course._id, { courseTitle: course.title }, req.ip);
        res.json({ message: 'Successfully enrolled in the course.', course });
    } catch (error) {
        console.error("Enroll Course Error:", error);
        res.status(500).json({ error: 'Failed to enroll in course.' });
    }
};

exports.unenrollFromCourse = async (req, res) => {
    try {
        const courseId = req.params.id;
        const userId = req.user._id;

        const course = await Course.findById(courseId);
        if (!course) {
            return res.status(404).json({ error: 'Course not found.' });
        }

        const studentIndex = course.studentIds.map(id => id.toString()).indexOf(userId.toString());
        if (studentIndex === -1) {
            return res.status(400).json({ message: 'Not enrolled in this course.' });
        }

        course.studentIds.splice(studentIndex, 1);
        await course.save();
        await logAction(req.user.id, 'UNENROLL_COURSE', 'Course', course._id, { courseTitle: course.title }, req.ip);
        res.json({ message: 'Successfully unenrolled from the course.', course });
    } catch (error) {
        console.error("Unenroll Course Error:", error);
        res.status(500).json({ error: 'Failed to unenroll from course.' });
    }
};

exports.getEnrolledCourses = async (req, res) => {
    try {
        const userId = req.user._id;
        const courses = await Course.find({ studentIds: userId, published: true })
            .select('title slug description coverImage category')
            .sort({ title: 1 });
        res.json(courses);
    } catch (error) {
        console.error("Get Enrolled Courses Error:", error);
        res.status(500).json({ error: 'Failed to retrieve enrolled courses.' });
    }
};


// --- Module Management within a Course ---
exports.addModuleToCourse = async (req, res) => {
    try {
        const courseId = req.params.courseId;
        const { moduleId } = req.body; // Expecting moduleId to be added

        if (!mongoose.Types.ObjectId.isValid(moduleId)) {
            return res.status(400).json({ error: "Invalid module ID." });
        }

        const course = await Course.findById(courseId);
        if (!course) return res.status(404).json({ error: "Course not found." });

        // Authorization (creator/admin/instructor)
        if (req.user.role !== 'admin' && req.user.role !== 'creator' && !course.instructorIds.map(id => id.toString()).includes(req.user._id.toString())) {
            return res.status(403).json({ error: 'Not authorized to modify this course.' });
        }

        const moduleExists = await Module.findById(moduleId);
        if (!moduleExists || moduleExists.courseId.toString() !== courseId) { // Ensure module belongs to this course or is being assigned
            // If module exists but belongs to another course, this logic might need adjustment based on UX flow
            // For now, assume module is created for this course or being linked
            return res.status(404).json({ error: "Module not found or does not belong to this course if trying to link existing."});
        }
        
        if (course.modules.map(id => id.toString()).includes(moduleId)) {
            return res.status(400).json({ error: "Module already in this course." });
        }
        
        course.modules.push(moduleId);
        course.lastUpdatedBy = req.user._id;
        await course.save();

        await logAction(req.user.id, 'ADD_MODULE_TO_COURSE', 'Course', courseId, { moduleId }, req.ip);
        res.status(200).json(course);
    } catch (error) {
        console.error("Add module to course error:", error);
        res.status(500).json({ error: "Failed to add module." });
    }
};

exports.updateModulesOrderInCourse = async (req, res) => {
    try {
        const courseId = req.params.courseId;
        const { orderedModuleIds } = req.body; // Expecting an array of module ObjectIds in the new order

        if (!Array.isArray(orderedModuleIds) || !orderedModuleIds.every(id => mongoose.Types.ObjectId.isValid(id))) {
            return res.status(400).json({ error: "Invalid module IDs array." });
        }

        const course = await Course.findById(courseId);
        if (!course) return res.status(404).json({ error: "Course not found." });

        // Authorization
        if (req.user.role !== 'admin' && req.user.role !== 'creator' && !course.instructorIds.map(id => id.toString()).includes(req.user._id.toString())) {
            return res.status(403).json({ error: 'Not authorized to modify this course.' });
        }

        // Validate that all provided module IDs actually exist in the course's modules array
        const currentModuleIds = course.modules.map(id => id.toString());
        const allProvidedIdsInCourse = orderedModuleIds.every(id => currentModuleIds.includes(id.toString()));
        if (orderedModuleIds.length !== currentModuleIds.length || !allProvidedIdsInCourse) {
            return res.status(400).json({ error: "Module list mismatch. Ensure all current course modules are provided in the new order." });
        }

        course.modules = orderedModuleIds.map(id => new mongoose.Types.ObjectId(id)); // Update the order
        course.lastUpdatedBy = req.user._id;
        await course.save();
        
        // Optionally, update 'order' field in each Module document (more complex, might not be needed if array order is source of truth)
        // For each module ID in orderedModuleIds, find the Module and update its 'order' field.
        await Promise.all(orderedModuleIds.map(async (moduleId, index) => {
            await Module.findByIdAndUpdate(moduleId, { order: index });
        }));


        await logAction(req.user.id, 'REORDER_COURSE_MODULES', 'Course', courseId, { newOrderCount: orderedModuleIds.length }, req.ip);
        res.status(200).json(course);
    } catch (error) {
        console.error("Reorder modules error:", error);
        res.status(500).json({ error: "Failed to reorder modules." });
    }
};

// removeModuleFromCourse would also be needed

===== File: /controllers/lessonController.js =====
// ===== File: /controllers/lessonController.js =====
const Lesson = require('../models/Lesson');
const Module = require('../models/Module');
const Course = require('../models/Course');
const Content = require('../models/Content');
// const Quiz = require('../models/Quiz'); // Uncomment when Quiz model exists
// const Assignment = require('../models/Assignment'); // Uncomment when Assignment model exists
const mongoose = require('mongoose');
const { validationResult, body } = require('express-validator');
const logAction = require('../utils/auditLogger');

exports.lessonCreateValidation = [
    body('title').trim().isLength({ min: 3 }).withMessage('Lesson title must be at least 3 characters.'),
    body('moduleId').isMongoId().withMessage('Valid Module ID is required.'),
    body('estimatedCompletionTimeMinutes').optional().isInt({ min: 0 }).withMessage('Estimated time must be a non-negative integer.'),
    body('published').optional().isBoolean()
];

exports.createLesson = async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
    }

    try {
        const { title, moduleId, estimatedCompletionTimeMinutes, published } = req.body;

        const module = await Module.findById(moduleId).populate({
            path: 'courseId',
            select: 'instructorIds createdBy'
        });

        if (!module) {
            return res.status(404).json({ error: 'Module not found. Cannot create lesson for non-existent module.' });
        }

        const course = module.courseId;
        const isCourseInstructorOrCreator = course.instructorIds.map(id => id.toString()).includes(req.user._id.toString()) || course.createdBy.toString() === req.user._id.toString();
        if (req.user.role !== 'admin' && req.user.role !== 'creator' && !isCourseInstructorOrCreator) {
            return res.status(403).json({ error: 'Not authorized to add lessons to this module.' });
        }
        
        const order = module.lessons.length;

        const lesson = new Lesson({
            title,
            moduleId,
            estimatedCompletionTimeMinutes,
            published: published || false,
            order,
            createdBy: req.user._id,
            lastUpdatedBy: req.user._id
        });
        await lesson.save();

        module.lessons.push(lesson._id);
        module.lastUpdatedBy = req.user._id;
        await module.save();
        await Course.findByIdAndUpdate(module.courseId._id, { lastUpdatedBy: req.user._id });


        await logAction(req.user.id, 'CREATE_LESSON', 'Lesson', lesson._id, { title: lesson.title, moduleId: lesson.moduleId, published: lesson.published }, req.ip);
        const populatedLesson = await Lesson.findById(lesson._id)
            .populate('createdBy', 'name email')
            .populate('moduleId', 'title');
        res.status(201).json(populatedLesson);
    } catch (error) {
        console.error("Create Lesson Error:", error);
        res.status(500).json({ error: 'Failed to create lesson.' });
    }
};

exports.getLessonsByModule = async (req, res) => {
    try {
        const moduleId = req.params.moduleId;
        if (!mongoose.Types.ObjectId.isValid(moduleId)) {
            return res.status(400).json({ error: 'Invalid Module ID.' });
        }
        const module = await Module.findById(moduleId)
            .populate({ path: 'courseId', select: 'instructorIds studentIds published createdBy' });
        if (!module) return res.status(404).json({ error: "Module not found."});

        const course = module.courseId;
        const query = { moduleId };

        const isCourseInstructorOrAdminCreator = req.user.role === 'admin' || req.user.role === 'creator' || (course && (course.instructorIds.map(id => id.toString()).includes(req.user._id.toString()) || course.createdBy.toString() === req.user._id.toString()));
        const isEnrolledStudentInPublishedCourseModule = course && course.published && module.published && (course.studentIds.map(id => id.toString()).includes(req.user._id.toString()));

        if (!isCourseInstructorOrAdminCreator && !isEnrolledStudentInPublishedCourseModule) {
            return res.status(403).json({ error: "Not authorized to view lessons for this module." });
        }
        if(!isCourseInstructorOrAdminCreator) {
             query.published = true;
        }
        
        const lessons = await Lesson.find(query)
            .populate('createdBy', 'name email')
            .populate('lastUpdatedBy', 'name email')
            .populate({
                path: 'items.itemId', 
                select: 'title topic itemType keyVocabulary learningObjectives' // Adjust fields
            })
            .sort({ order: 1 });
        res.json(lessons);
    } catch (error) {
        console.error("Get Lessons by Module Error:", error);
        res.status(500).json({ error: 'Failed to retrieve lessons.' });
    }
};

exports.getLessonById = async (req, res) => {
    try {
        const lessonId = req.params.id;
        if (!mongoose.Types.ObjectId.isValid(lessonId)) {
            return res.status(400).json({ error: 'Invalid Lesson ID.' });
        }
        const lesson = await Lesson.findById(lessonId)
            .populate('createdBy', 'name email')
            .populate('lastUpdatedBy', 'name email')
            .populate({
                path: 'moduleId',
                populate: {
                    path: 'courseId',
                    select: 'instructorIds studentIds published createdBy title slug'
                }
            })
            .populate('items.itemId'); 

        if (!lesson) {
            return res.status(404).json({ error: 'Lesson not found.' });
        }
        
        const module = lesson.moduleId;
        const course = module.courseId;

        const isCourseInstructorOrAdminCreator = req.user.role === 'admin' || req.user.role === 'creator' || (course && (course.instructorIds.map(id => id.toString()).includes(req.user._id.toString()) || course.createdBy.toString() === req.user._id.toString()));
        const isEnrolledStudentInPublishedCourseModuleLesson = course && course.published && module.published && lesson.published && (course.studentIds.map(id => id.toString()).includes(req.user._id.toString()));

        if (!isCourseInstructorOrAdminCreator && !isEnrolledStudentInPublishedCourseModuleLesson) {
            return res.status(403).json({ error: 'Not authorized to view this lesson.' });
        }
        
        res.json(lesson);
    } catch (error) {
        console.error("Get Lesson By ID Error:", error);
        res.status(500).json({ error: 'Failed to retrieve lesson.' });
    }
};

exports.updateLesson = async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
    }
    try {
        const lessonId = req.params.id;
        const { title, estimatedCompletionTimeMinutes, published, order } = req.body;

        let lesson = await Lesson.findById(lessonId).populate({
            path: 'moduleId',
            populate: { path: 'courseId', select: 'instructorIds createdBy' }
        });
        if (!lesson) return res.status(404).json({ error: "Lesson not found." });

        const course = lesson.moduleId.courseId;
        const isCourseInstructorOrCreator = course.instructorIds.map(id => id.toString()).includes(req.user._id.toString()) || course.createdBy.toString() === req.user._id.toString();
        if (req.user.role !== 'admin' && req.user.role !== 'creator' && !isCourseInstructorOrCreator) {
            return res.status(403).json({ error: 'Not authorized to update this lesson.' });
        }

        const oldValues = { title: lesson.title, published: lesson.published, order: lesson.order };
        const changes = {};

        if (title && title !== lesson.title) { lesson.title = title; changes.title = { old: oldValues.title, new: lesson.title }; }
        if (estimatedCompletionTimeMinutes !== undefined) lesson.estimatedCompletionTimeMinutes = estimatedCompletionTimeMinutes; // Not tracking for audit
        if (published !== undefined && published !== lesson.published) { lesson.published = published; changes.published = { old: oldValues.published, new: lesson.published };}
        if (order !== undefined && typeof order === 'number' && order !== lesson.order) {
             lesson.order = order; changes.order = { old: oldValues.order, new: lesson.order };
        }
        
        if (Object.keys(changes).length > 0) {
            lesson.lastUpdatedBy = req.user._id;
            await lesson.save();
            await Module.findByIdAndUpdate(lesson.moduleId._id, { lastUpdatedBy: req.user._id });
            await Course.findByIdAndUpdate(lesson.moduleId.courseId._id, { lastUpdatedBy: req.user._id });

            await logAction(req.user.id, 'UPDATE_LESSON', 'Lesson', lesson._id, { changes }, req.ip);
        }
        const populatedLesson = await Lesson.findById(lesson._id)
            .populate('createdBy', 'name email')
            .populate('lastUpdatedBy', 'name email')
            .populate('moduleId', 'title');
        res.json(populatedLesson);

    } catch (error) {
        console.error("Update Lesson Error:", error);
        res.status(500).json({ error: 'Failed to update lesson.' });
    }
};

exports.deleteLesson = async (req, res) => {
    try {
        const lessonId = req.params.id;
        const lesson = await Lesson.findById(lessonId).populate({
            path: 'moduleId',
            select: 'lessons courseId',
            populate: { path: 'courseId', select: 'instructorIds createdBy' }
        });
        if (!lesson) return res.status(404).json({ error: "Lesson not found." });

        const module = lesson.moduleId;
        const course = module.courseId;
        const isCourseInstructorOrCreator = course.instructorIds.map(id => id.toString()).includes(req.user._id.toString()) || course.createdBy.toString() === req.user._id.toString();
        if (req.user.role !== 'admin' && req.user.role !== 'creator' && !isCourseInstructorOrCreator) {
            return res.status(403).json({ error: 'Not authorized to delete this lesson.' });
        }
        
        const deletedTitle = lesson.title;
        const parentModuleId = lesson.moduleId._id;

        // Remove lesson reference from parent module
        await Module.findByIdAndUpdate(parentModuleId, {
            $pull: { lessons: lessonId },
            lastUpdatedBy: req.user._id
        });
        await Course.findByIdAndUpdate(lesson.moduleId.courseId._id, { lastUpdatedBy: req.user._id });
        
        // Lesson items are just references, so deleting the lesson doesn't delete the underlying Content/Quiz/Assignment docs.
        // This is generally desired behavior for reusability of content.
        await lesson.remove(); // Using .remove() though no specific pre-remove hook for Lesson currently

        await logAction(req.user.id, 'DELETE_LESSON', 'Lesson', lessonId, { title: deletedTitle, moduleId: parentModuleId }, req.ip);
        res.json({ message: `Lesson "${deletedTitle}" deleted successfully.` });

    } catch (error) {
        console.error("Delete Lesson Error:", error);
        res.status(500).json({ error: 'Failed to delete lesson.' });
    }
};


// --- Lesson Item Management ---
exports.lessonItemValidation = [
    body('itemType').isIn(['Content', 'Quiz', 'Assignment', 'ExternalLink', 'Discussion']).withMessage('Invalid item type.'),
    body('itemId').isMongoId().withMessage('Valid Item ID is required.'),
    body('titleOverride').optional().trim()
];

const getItemModel = (itemType) => {
    switch (itemType) {
        case 'Content': return Content;
        // case 'Quiz': return Quiz;
        // case 'Assignment': return Assignment;
        default: return null;
    }
};

exports.addItemToLesson = async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
    }
    try {
        const lessonId = req.params.lessonId;
        const { itemType, itemId, titleOverride } = req.body;

        let lesson = await Lesson.findById(lessonId).populate({
            path: 'moduleId',
            populate: { path: 'courseId', select: 'instructorIds createdBy' }
        });
        if (!lesson) return res.status(404).json({ error: "Lesson not found." });
        
        const course = lesson.moduleId.courseId;
        const isCourseInstructorOrCreator = course.instructorIds.map(id => id.toString()).includes(req.user._id.toString()) || course.createdBy.toString() === req.user._id.toString();
        if (req.user.role !== 'admin' && req.user.role !== 'creator' && !isCourseInstructorOrCreator) {
            return res.status(403).json({ error: 'Not authorized to modify this lesson.' });
        }
        
        const ItemModel = getItemModel(itemType);
        if (!ItemModel && itemType !== 'ExternalLink' && itemType !== 'Discussion') { // Allow non-model types for now
            return res.status(400).json({ error: `Linking of item type '${itemType}' is not fully supported yet or model missing.` });
        }
        
        let itemExists;
        if (ItemModel) {
            itemExists = await ItemModel.findById(itemId);
            if (!itemExists) return res.status(404).json({ error: `${itemType} with ID ${itemId} not found.` });
        } else if (itemType === 'ExternalLink' || itemType === 'Discussion') {
            // For these types, itemId might not be a Mongoose ObjectId if it's just a URL or a placeholder
            // For now, let's assume itemId is still an ObjectId that points to some other record if needed
            // or we need a different validation path if itemId can be a string URL for 'ExternalLink'
            // This part needs more definition for ExternalLink/Discussion if itemId isn't an ObjectId
            if (!mongoose.Types.ObjectId.isValid(itemId) && itemType !== 'ExternalLink'){ // Allow non-ObjectId for ExternalLink if itemId is the URL itself
                 // return res.status(400).json({ error: `ItemID must be a valid ID for ${itemType}.` });
            }
             // For ExternalLink, the 'itemId' might be the URL itself or a placeholder, and 'titleOverride' the display text
             // itemExists can be a placeholder object for logging
             itemExists = { title: titleOverride || itemId, _id: itemId };
        }


        const existingItemIndex = lesson.items.findIndex(item => item.itemId.toString() === itemId.toString() && item.itemType === itemType);
        if (existingItemIndex > -1) {
            return res.status(400).json({ error: `${itemType} is already in this lesson.` });
        }
        
        const order = lesson.items.length;

        lesson.items.push({ itemType, itemId, titleOverride, order });
        lesson.lastUpdatedBy = req.user._id;
        await lesson.save();
        
        await Module.findByIdAndUpdate(lesson.moduleId._id, { lastUpdatedBy: req.user._id });
        await Course.findByIdAndUpdate(lesson.moduleId.courseId._id, { lastUpdatedBy: req.user._id });

        await logAction(req.user.id, 'ADD_ITEM_TO_LESSON', 'Lesson', lessonId, { itemType, itemId: itemId.toString(), itemTitle: itemExists?.title || itemExists?.topic || titleOverride }, req.ip);
        const populatedLesson = await Lesson.findById(lessonId).populate('items.itemId');
        res.status(200).json(populatedLesson);

    } catch (error) {
        console.error("Add item to lesson error:", error);
        res.status(500).json({ error: "Failed to add item to lesson." });
    }
};

exports.removeItemFromLesson = async (req, res) => {
    try {
        const lessonId = req.params.lessonId;
        // Item is identified by its own itemId AND itemType within the lesson's items array.
        // The client needs to send which specific sub-item (by its itemId and itemType) to remove.
        const { lessonItemId } = req.body; // This should be the _id of the subdocument in the items array for direct removal.
                                          // OR, if removing by itemId and itemType: const { itemId, itemType } = req.body;
                                          
        if (!mongoose.Types.ObjectId.isValid(lessonId)) {
            return res.status(400).json({ error: "Invalid lesson ID."});
        }

        let lesson = await Lesson.findById(lessonId).populate({
            path: 'moduleId',
            populate: { path: 'courseId', select: 'instructorIds createdBy' }
        });
        if (!lesson) return res.status(404).json({ error: "Lesson not found." });

        const course = lesson.moduleId.courseId;
        const isCourseInstructorOrCreator = course.instructorIds.map(id => id.toString()).includes(req.user._id.toString()) || course.createdBy.toString() === req.user._id.toString();
        if (req.user.role !== 'admin' && req.user.role !== 'creator' && !isCourseInstructorOrCreator) {
            return res.status(403).json({ error: 'Not authorized to modify this lesson.' });
        }
        
        // Option 1: Remove by _id of the subdocument (if subdocuments have _id, which they don't by default with {_id: false})
        // If lessonItemSchema had _id: true (default), then lessonItemId would be that _id.
        // lesson.items.id(lessonItemId).remove(); // Mongoose subdocument removal

        // Option 2: Remove by combination of itemId and itemType (more robust if subdoc _id is not stable or available)
        const { itemId, itemType } = req.body; // Expect these if not using subdocument _id
        if (!itemId || !itemType) {
            return res.status(400).json({error: "itemId and itemType are required to identify the lesson item."})
        }

        const itemIndex = lesson.items.findIndex(item => item.itemId.toString() === itemId.toString() && item.itemType === itemType);
        if (itemIndex === -1) {
            return res.status(404).json({ error: "Item not found in this lesson." });
        }
        const removedItemDetails = lesson.items[itemIndex];
        lesson.items.splice(itemIndex, 1);
        
        // Re-order remaining items
        lesson.items.forEach((item, index) => item.order = index);

        lesson.lastUpdatedBy = req.user._id;
        await lesson.save();
        
        await Module.findByIdAndUpdate(lesson.moduleId._id, { lastUpdatedBy: req.user._id });
        await Course.findByIdAndUpdate(lesson.moduleId.courseId._id, { lastUpdatedBy: req.user._id });

        await logAction(req.user.id, 'REMOVE_ITEM_FROM_LESSON', 'Lesson', lessonId, { itemType: removedItemDetails.itemType, itemId: removedItemDetails.itemId.toString() }, req.ip);
        const populatedLesson = await Lesson.findById(lessonId).populate('items.itemId');
        res.status(200).json(populatedLesson);

    } catch (error) {
        console.error("Remove item from lesson error:", error);
        res.status(500).json({ error: "Failed to remove item from lesson." });
    }
};


exports.updateLessonItemsOrder = async (req, res) => {
    try {
        const lessonId = req.params.lessonId;
        // orderedLessonItemSubdocuments should be array of { itemId, itemType, titleOverride (optional) }
        const { orderedLessonItemSubdocuments } = req.body; 

        if (!Array.isArray(orderedLessonItemSubdocuments)) {
            return res.status(400).json({ error: "Invalid lesson items array."});
        }
        
        for (const item of orderedLessonItemSubdocuments) {
            if (!item.itemId || !item.itemType || (item.itemId && !mongoose.Types.ObjectId.isValid(item.itemId.toString()) && item.itemType !== 'ExternalLink') ) { // Allow non-ObjectId for ExternalLink if itemId is the URL
                 return res.status(400).json({ error: `Each lesson item must have a valid itemId (unless ExternalLink with URL as ID) and itemType. Problem with: ${JSON.stringify(item)}`});
            }
        }

        let lesson = await Lesson.findById(lessonId).populate({
            path: 'moduleId',
            populate: { path: 'courseId', select: 'instructorIds createdBy' }
        });
        if (!lesson) return res.status(404).json({ error: "Lesson not found." });
        
        const course = lesson.moduleId.courseId;
        const isCourseInstructorOrCreator = course.instructorIds.map(id => id.toString()).includes(req.user._id.toString()) || course.createdBy.toString() === req.user._id.toString();
        if (req.user.role !== 'admin' && req.user.role !== 'creator' && !isCourseInstructorOrCreator) {
            return res.status(403).json({ error: 'Not authorized to modify this lesson.' });
        }

        // Ensure all items in orderedLessonItemSubdocuments are currently in the lesson
        const currentItemUniqueKeys = lesson.items.map(li => `${li.itemType}-${li.itemId.toString()}`);
        const providedItemUniqueKeys = orderedLessonItemSubdocuments.map(li => `${li.itemType}-${li.itemId.toString()}`);

        if (currentItemUniqueKeys.length !== providedItemUniqueKeys.length || !providedItemUniqueKeys.every(key => currentItemUniqueKeys.includes(key))) {
            return res.status(400).json({ error: "Lesson item list mismatch. Ensure all and only current lesson items are provided in the new order." });
        }
        
        lesson.items = orderedLessonItemSubdocuments.map((itemData, index) => ({
            itemType: itemData.itemType,
            itemId: itemData.itemType === 'ExternalLink' ? itemData.itemId : new mongoose.Types.ObjectId(itemData.itemId), // Handle ExternalLink itemId potentially being a string URL
            titleOverride: itemData.titleOverride,
            order: index 
        }));

        lesson.lastUpdatedBy = req.user._id;
        await lesson.save();
        
        await Module.findByIdAndUpdate(lesson.moduleId._id, { lastUpdatedBy: req.user._id });
        await Course.findByIdAndUpdate(lesson.moduleId.courseId._id, { lastUpdatedBy: req.user._id });
        
        await logAction(req.user.id, 'REORDER_LESSON_ITEMS', 'Lesson', lessonId, { newOrderCount: orderedLessonItemSubdocuments.length }, req.ip);
        const populatedLesson = await Lesson.findById(lessonId).populate('items.itemId');
        res.status(200).json(populatedLesson);
    } catch (error) {
        console.error("Reorder lesson items error:", error);
        res.status(500).json({ error: "Failed to reorder lesson items." });
    }
};

===== File: /controllers/moduleController.js =====
// ===== File: /controllers/moduleController.js =====
const Module = require('../models/Module');
const Course = require('../models/Course');
const Lesson = require('../models/Lesson');
const mongoose = require('mongoose');
const { validationResult, body } = require('express-validator');
const logAction = require('../utils/auditLogger');

exports.moduleCreateValidation = [
    body('title').trim().isLength({ min: 3 }).withMessage('Module title must be at least 3 characters.'),
    body('description').optional().trim(),
    body('courseId').isMongoId().withMessage('Valid Course ID is required.'),
    body('moduleLearningObjectives').optional().isArray().withMessage('Module learning objectives must be an array of strings.'),
    body('moduleLearningObjectives.*').optional().isString().trim(),
    body('published').optional().isBoolean()
];

exports.createModule = async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
    }

    try {
        const { title, description, courseId, moduleLearningObjectives, published } = req.body;

        const course = await Course.findById(courseId);
        if (!course) {
            return res.status(404).json({ error: 'Course not found. Cannot create module for non-existent course.' });
        }

        const isCourseInstructor = course.instructorIds.map(id => id.toString()).includes(req.user._id.toString());
        if (req.user.role !== 'admin' && req.user.role !== 'creator' && !isCourseInstructor) {
            return res.status(403).json({ error: 'Not authorized to add modules to this course.' });
        }
        
        const order = course.modules.length; // New module gets next order number

        const module = new Module({
            title,
            description,
            courseId,
            moduleLearningObjectives: moduleLearningObjectives || [],
            published: published || false,
            order,
            createdBy: req.user._id,
            lastUpdatedBy: req.user._id
        });
        await module.save();

        // Add module to course's module list and update course's lastUpdatedBy
        course.modules.push(module._id);
        course.lastUpdatedBy = req.user._id;
        await course.save();

        await logAction(req.user.id, 'CREATE_MODULE', 'Module', module._id, { title: module.title, courseId: module.courseId, published: module.published }, req.ip);
        const populatedModule = await Module.findById(module._id)
            .populate('createdBy', 'name email')
            .populate('courseId', 'title slug');
        res.status(201).json(populatedModule);
    } catch (error) {
        console.error("Create Module Error:", error);
        res.status(500).json({ error: 'Failed to create module.' });
    }
};

exports.getModulesByCourse = async (req, res) => {
    try {
        const courseId = req.params.courseId;
        if (!mongoose.Types.ObjectId.isValid(courseId)) {
            return res.status(400).json({ error: 'Invalid Course ID.' });
        }
        const course = await Course.findById(courseId).select('instructorIds studentIds published createdBy');
        if (!course) return res.status(404).json({ error: "Course not found."});

        const query = { courseId };
        const isCourseInstructor = course.instructorIds.map(id => id.toString()).includes(req.user._id.toString());
        const isEnrolledStudent = course.studentIds.map(id => id.toString()).includes(req.user._id.toString());

        // Authorization to list modules
        if (req.user.role !== 'admin' && req.user.role !== 'creator' && !isCourseInstructor && !isEnrolledStudent) {
            return res.status(403).json({ error: "Not authorized to view modules for this course." });
        }
        // Students only see published modules of published courses they are in
        if (req.user.role === 'user' && (!course.published || !isEnrolledStudent)) {
             return res.status(403).json({ error: "Not authorized or course/module is not available." });
        }
        if (req.user.role === 'user') { // Applies to enrolled students viewing published course
            query.published = true;
        }
        
        const modules = await Module.find(query)
            .populate('createdBy', 'name email')
            .populate('lastUpdatedBy', 'name email')
            .populate({
                path: 'lessons',
                match: (req.user.role === 'user') ? { published: true } : {},
                options: { sort: { order: 1 } },
                select: 'title published order items', // Select necessary fields for lesson list
                populate: {
                    path: 'items.itemId',
                    select: 'title topic' // Adjust as needed
                }
            })
            .sort({ order: 1 });
        res.json(modules);
    } catch (error) {
        console.error("Get Modules by Course Error:", error);
        res.status(500).json({ error: 'Failed to retrieve modules.' });
    }
};

exports.getModuleById = async (req, res) => {
    try {
        const moduleId = req.params.id;
        if (!mongoose.Types.ObjectId.isValid(moduleId)) {
            return res.status(400).json({ error: 'Invalid Module ID.' });
        }
        const module = await Module.findById(moduleId)
            .populate('createdBy', 'name email')
            .populate('lastUpdatedBy', 'name email')
            .populate({ path: 'courseId', select: 'title slug instructorIds studentIds published createdBy' })
            .populate({
                path: 'lessons',
                match: (req.user.role === 'user' && !req.query.manageView) ? { published: true } : {},
                options: { sort: { order: 1 } },
                populate: {
                    path: 'items.itemId',
                    select: 'title topic originalText itemType'
                }
            });

        if (!module) {
            return res.status(404).json({ error: 'Module not found.' });
        }
        
        const course = module.courseId; // Populated course
        const isCourseInstructor = course && course.instructorIds.map(id => id.toString()).includes(req.user._id.toString());
        const isEnrolledStudent = course && course.studentIds.map(id => id.toString()).includes(req.user._id.toString());

        const isAuthorized = req.user.role === 'admin' || 
                             req.user.role === 'creator' ||
                             isCourseInstructor ||
                             (course && course.published && module.published && isEnrolledStudent);

        if (!isAuthorized) {
            return res.status(403).json({ error: 'Not authorized to view this module.' });
        }
        
        // Filter lessons again for student view if match didn't catch it (belt and suspenders)
        if (req.user.role === 'user' && !req.query.manageView && module.lessons) {
            module.lessons = module.lessons.filter(lesson => lesson.published);
        }

        res.json(module);
    } catch (error) {
        console.error("Get Module By ID Error:", error);
        res.status(500).json({ error: 'Failed to retrieve module.' });
    }
};

exports.updateModule = async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
    }
    try {
        const moduleId = req.params.id;
        const { title, description, moduleLearningObjectives, published, order } = req.body;

        let module = await Module.findById(moduleId).populate('courseId', 'instructorIds');
        if (!module) return res.status(404).json({ error: "Module not found." });

        const course = module.courseId;
        const isCourseInstructor = course.instructorIds.map(id => id.toString()).includes(req.user._id.toString());
        if (req.user.role !== 'admin' && req.user.role !== 'creator' && !isCourseInstructor) {
            return res.status(403).json({ error: 'Not authorized to update this module.' });
        }
        
        const oldValues = { title: module.title, description: module.description, published: module.published, order: module.order };
        const changes = {};

        if (title && title !== module.title) { module.title = title; changes.title = { old: oldValues.title, new: module.title };}
        if (description !== undefined && description !== module.description) { module.description = description; changes.description = "modified"; }
        if (moduleLearningObjectives !== undefined) {
            if (JSON.stringify(module.moduleLearningObjectives.slice().sort()) !== JSON.stringify(moduleLearningObjectives.slice().sort())) {
                module.moduleLearningObjectives = moduleLearningObjectives;
                changes.moduleLearningObjectives = "modified";
            }
        }
        if (published !== undefined && published !== module.published) { module.published = published; changes.published = { old: oldValues.published, new: module.published };}
        if (order !== undefined && typeof order === 'number' && order !== module.order) {
            module.order = order;
            changes.order = { old: oldValues.order, new: module.order };
            // If order changes, sibling modules in the same course might need their orders adjusted.
            // This is complex and often handled by a dedicated reorder endpoint.
            // For now, this directly sets the order.
        }

        if (Object.keys(changes).length > 0) {
            module.lastUpdatedBy = req.user._id;
            await module.save();
            
            // Update course's lastUpdatedBy timestamp as well
            await Course.findByIdAndUpdate(module.courseId._id, { lastUpdatedBy: req.user._id });

            await logAction(req.user.id, 'UPDATE_MODULE', 'Module', module._id, { changes }, req.ip);
        }
        const populatedModule = await Module.findById(module._id)
            .populate('createdBy', 'name email')
            .populate('lastUpdatedBy', 'name email')
            .populate('courseId', 'title slug');
        res.json(populatedModule);

    } catch (error) {
        console.error("Update Module Error:", error);
        res.status(500).json({ error: 'Failed to update module.' });
    }
};

exports.deleteModule = async (req, res) => {
    try {
        const moduleId = req.params.id;
        const module = await Module.findById(moduleId).populate('courseId', 'instructorIds modules createdBy');
        if (!module) return res.status(404).json({ error: "Module not found." });

        const course = module.courseId;
        const isCourseInstructorOrCreator = course.instructorIds.map(id => id.toString()).includes(req.user._id.toString()) || course.createdBy.toString() === req.user._id.toString();

        if (req.user.role !== 'admin' && req.user.role !== 'creator' && !isCourseInstructorOrCreator) {
            return res.status(403).json({ error: 'Not authorized to delete this module. Must be admin, course creator, or instructor.' });
        }
        
        const deletedTitle = module.title;
        const parentCourseId = module.courseId._id;
        const lessonCount = module.lessons.length;

        // Remove module reference from parent course
        await Course.findByIdAndUpdate(parentCourseId, {
            $pull: { modules: moduleId },
            lastUpdatedBy: req.user._id
        });

        // The `pre('remove')` hook on Module model will delete associated Lessons.
        await module.remove(); // Use .remove() to trigger middleware

        await logAction(req.user.id, 'DELETE_MODULE', 'Module', moduleId, { title: deletedTitle, courseId: parentCourseId, deletedLessonsCount: lessonCount }, req.ip);
        res.json({ message: `Module "${deletedTitle}" and its lessons deleted successfully.` });

    } catch (error) {
        console.error("Delete Module Error:", error);
        res.status(500).json({ error: 'Failed to delete module.' });
    }
};


// --- Lesson Management within a Module ---
exports.addLessonToModule = async (req, res) => {
    try {
        const moduleId = req.params.moduleId;
        const { lessonId } = req.body; 

        if (!mongoose.Types.ObjectId.isValid(lessonId) || !mongoose.Types.ObjectId.isValid(moduleId)) {
            return res.status(400).json({ error: "Invalid module or lesson ID." });
        }

        const module = await Module.findById(moduleId).populate('courseId', 'instructorIds createdBy');
        if (!module) return res.status(404).json({ error: "Module not found." });

        const course = module.courseId;
        const isCourseInstructorOrCreator = course.instructorIds.map(id => id.toString()).includes(req.user._id.toString()) || course.createdBy.toString() === req.user._id.toString();
        if (req.user.role !== 'admin' && req.user.role !== 'creator' && !isCourseInstructorOrCreator) {
            return res.status(403).json({ error: 'Not authorized to modify this module.' });
        }

        const lessonToAdd = await Lesson.findById(lessonId);
        if (!lessonToAdd) {
            return res.status(404).json({ error: "Lesson to add not found."});
        }
        if(lessonToAdd.moduleId.toString() !== moduleId) {
            return res.status(400).json({ error: "Lesson does not belong to this module. Update lesson's moduleId first if moving."});
        }
        
        if (module.lessons.map(id => id.toString()).includes(lessonId)) {
            return res.status(400).json({ error: "Lesson already in this module's list." });
        }
        
        lessonToAdd.order = module.lessons.length;
        await lessonToAdd.save();

        module.lessons.push(lessonId);
        module.lastUpdatedBy = req.user._id;
        await module.save();
        
        // Update course's lastUpdatedBy timestamp
        await Course.findByIdAndUpdate(module.courseId._id, { lastUpdatedBy: req.user._id });

        await logAction(req.user.id, 'ADD_LESSON_TO_MODULE', 'Module', moduleId, { lessonId, lessonTitle: lessonToAdd.title }, req.ip);
        const populatedModule = await Module.findById(moduleId).populate({ path: 'lessons', options: { sort: {order: 1 }}});
        res.status(200).json(populatedModule);
    } catch (error) {
        console.error("Add lesson to module error:", error);
        res.status(500).json({ error: "Failed to add lesson to module." });
    }
};

exports.removeLessonFromModule = async (req, res) => {
    try {
        const moduleId = req.params.moduleId;
        const { lessonId } = req.body;

        if (!mongoose.Types.ObjectId.isValid(lessonId) || !mongoose.Types.ObjectId.isValid(moduleId)) {
            return res.status(400).json({ error: "Invalid module or lesson ID." });
        }

        const module = await Module.findById(moduleId).populate('courseId', 'instructorIds createdBy');
        if (!module) return res.status(404).json({ error: "Module not found." });

        const course = module.courseId;
        const isCourseInstructorOrCreator = course.instructorIds.map(id => id.toString()).includes(req.user._id.toString()) || course.createdBy.toString() === req.user._id.toString();
        if (req.user.role !== 'admin' && req.user.role !== 'creator' && !isCourseInstructorOrCreator) {
            return res.status(403).json({ error: 'Not authorized to modify this module.' });
        }
        
        const lessonIndex = module.lessons.map(id => id.toString()).indexOf(lessonId);
        if (lessonIndex === -1) {
            return res.status(404).json({ error: "Lesson not found in this module's list." });
        }

        module.lessons.splice(lessonIndex, 1);
        // Re-order subsequent lessons
        for (let i = lessonIndex; i < module.lessons.length; i++) {
            const lessIdToUpdate = module.lessons[i];
            await Lesson.findByIdAndUpdate(lessIdToUpdate, { order: i });
        }

        module.lastUpdatedBy = req.user._id;
        await module.save();
        await Course.findByIdAndUpdate(module.courseId._id, { lastUpdatedBy: req.user._id });
        
        // This does not delete the Lesson document itself.
        await logAction(req.user.id, 'REMOVE_LESSON_FROM_MODULE', 'Module', moduleId, { lessonId }, req.ip);
        const populatedModule = await Module.findById(moduleId).populate({ path: 'lessons', options: { sort: {order: 1 }}});
        res.status(200).json(populatedModule);
    } catch (error) {
        console.error("Remove lesson from module error:", error);
        res.status(500).json({ error: "Failed to remove lesson from module." });
    }
};


exports.updateLessonsOrderInModule = async (req, res) => {
    try {
        const moduleId = req.params.moduleId;
        const { orderedLessonIds } = req.body;

        if (!Array.isArray(orderedLessonIds) || !orderedLessonIds.every(id => mongoose.Types.ObjectId.isValid(id))) {
            return res.status(400).json({ error: "Invalid lesson IDs array." });
        }

        const module = await Module.findById(moduleId).populate('courseId', 'instructorIds createdBy');
        if (!module) return res.status(404).json({ error: "Module not found." });

        const course = module.courseId;
        const isCourseInstructorOrCreator = course.instructorIds.map(id => id.toString()).includes(req.user._id.toString()) || course.createdBy.toString() === req.user._id.toString();
        if (req.user.role !== 'admin' && req.user.role !== 'creator' && !isCourseInstructorOrCreator) {
            return res.status(403).json({ error: 'Not authorized to modify this module.' });
        }
        
        const currentLessonIdsInModule = module.lessons.map(id => id.toString());
        const allProvidedIdsAreValidAndInModule = orderedLessonIds.every(id => currentLessonIdsInModule.includes(id.toString()));

        if (orderedLessonIds.length !== currentLessonIdsInModule.length || !allProvidedIdsAreValidAndInModule) {
            return res.status(400).json({ error: "Lesson list mismatch. Ensure all and only current module lessons are provided." });
        }

        module.lessons = orderedLessonIds.map(id => new mongoose.Types.ObjectId(id));
        module.lastUpdatedBy = req.user._id;
        await module.save();

        await Promise.all(orderedLessonIds.map(async (lessonId, index) => {
            await Lesson.findByIdAndUpdate(lessonId, { order: index, lastUpdatedBy: req.user._id });
        }));
        
        await Course.findByIdAndUpdate(module.courseId._id, { lastUpdatedBy: req.user._id });

        await logAction(req.user.id, 'REORDER_MODULE_LESSONS', 'Module', moduleId, { newOrderCount: orderedLessonIds.length }, req.ip);
        const populatedModule = await Module.findById(moduleId).populate({ path: 'lessons', options: { sort: { order: 1 } } });
        res.status(200).json(populatedModule);
    } catch (error) {
        console.error("Reorder lessons error:", error);
        res.status(500).json({ error: "Failed to reorder lessons." });
    }
};

===== File: /controllers/qaController.js =====
// ===== File: /controllers/qaController.js =====
const axios = require('axios');
const Session = require('../models/Session');
const Content = require('../models/Content');
const User = require('../models/User');
const mongoose = require('mongoose'); // For ObjectId validation

const OPENROUTER_API_KEY = process.env.OPENROUTER_API_KEY;
const OPENROUTER_DEFAULT_MODEL = process.env.OPENROUTER_DEFAULT_MODEL || 'mistralai/mistral-7b-instruct:free'; // or a better free/paid model
const YOUR_SITE_URL = process.env.YOUR_SITE_URL || 'http://localhost:3000'; // Replace with your actual site URL
const YOUR_SITE_NAME = process.env.YOUR_SITE_NAME || 'AccessibleLearningPortal'; // Replace with your actual site name

const mapReadingLevelToSimplifyLevel = (readingLevel) => {
  switch (readingLevel?.toLowerCase()) {
    case 'eli5': return 'eli5';
    case 'basic': case 'easy': return 'easy';
    case 'intermediate': case 'moderate': return 'moderate';
    case 'advanced': return 'advanced';
    case 'high_school': return 'high_school';
    case 'college_intro': return 'college_intro';
    default: return 'easy';
  }
};

exports.askQuestion = async (req, res) => {
  try {
    const { question, topic, contentId } = req.body; // contentId is optional, topic is slug
    const userId = req.user._id;

    if (!question || !topic) {
      return res.status(400).json({ error: 'Question and topic (slug) are required.' });
    }
    if (contentId && !mongoose.Types.ObjectId.isValid(contentId)) {
        return res.status(400).json({ error: 'Invalid contentId format.' });
    }


    const user = await User.findById(userId).select('preferences');
    const userReadingLevel = user?.preferences?.readingLevel || 'basic'; // Default reading level
    // Use the new granular map for context fetching, if applicable
    const preferredSimplifyLevelForContext = mapReadingLevelToSimplifyLevel(userReadingLevel);

    let contentDoc;
    if (contentId) {
        contentDoc = await Content.findById(contentId);
    } else if (topic) { // Fallback to topic slug if no ID
        contentDoc = await Content.findOne({ topic: topic.toLowerCase().trim() });
    }

    let contextText = "General knowledge. The student is asking about a topic for which specific context was not found in the database.";
    let contextUsed = 'general_knowledge';

    if (contentDoc) {
        const preferredSimplifiedVersion = contentDoc.simplifiedVersions.find(v => v.level === preferredSimplifyLevelForContext);
        if (preferredSimplifiedVersion) {
            contextText = preferredSimplifiedVersion.text;
            contextUsed = `simplified_${preferredSimplifyLevelForContext}`;
        } else {
            // Fallback to any 'easy' or 'eli5' simplified version if preferred not found
            const easyVersion = contentDoc.simplifiedVersions.find(v => v.level === 'easy' || v.level === 'eli5');
            if (easyVersion) {
                contextText = easyVersion.text;
                contextUsed = `simplified_${easyVersion.level}`;
            } else {
                contextText = contentDoc.originalText; // Fallback to original
                contextUsed = 'original';
            }
        }
    } else {
         console.warn(`QA: Content not found for topic "${topic}" or ID "${contentId}", using general context.`);
    }

    // Fetch last 2-3 interactions for context
    const sessionData = await Session.findOne({ userId: userId }).sort({ 'interactions.timestamp': -1 });
    let previousInteractionsContext = "";
    if (sessionData && sessionData.interactions && sessionData.interactions.length > 0) {
        const relevantInteractions = sessionData.interactions
            .filter(inter => inter.topic === (contentDoc?.topic || topic)) // Filter by current topic slug
            .slice(-3); // Get last 3, adjust as needed
        if (relevantInteractions.length > 0) {
            previousInteractionsContext = "\nPrevious conversation on this topic:\n" +
                relevantInteractions.map(inter => `Student: ${inter.question || 'User performed an action.'}\nTutor: ${inter.answer || 'System responded.'}`).join("\n---\n") + // Handle non-question interactions gracefully
                "\n--- (End of previous conversation) ---\n";
        }
    }

    let promptIntro = `You are a friendly, patient, and helpful AI tutor for a neurodivergent student. The student's preferred reading level is '${userReadingLevel}'. Adapt your language complexity accordingly.`;
    if (user?.preferences?.preferredContentMode === 'visual') {
        promptIntro += " The student sometimes benefits from analogies or visualizable descriptions if appropriate for the question."
    }
    promptIntro += " If the student seems stuck, confused by your explanation, or asks multiple clarifying questions about the same small detail, proactively offer to explain it differently, provide an example, or break it down further. Your goal is to ensure understanding and build confidence."


    const prompt = `${promptIntro}
${previousInteractionsContext}
Current Topic Context ("${contentDoc?.topic.replace(/-/g,' ') || topic}"):
---
${contextText.substring(0, 3000)}
---
Based *primarily* on the provided context and recent conversation, answer the student's question. If the context is insufficient, you may use your general knowledge but state that you are doing so. If the question is completely outside the context and your general knowledge, clearly say you don't have the information or cannot help with that specific type of query.
Student's Current Question: "${question}"
AI Tutor's Answer:`;

    const startTime = Date.now();
    const response = await axios.post(
      'https://openrouter.ai/api/v1/chat/completions',
      {
        model: OPENROUTER_DEFAULT_MODEL,
        messages: [
          { role: 'system', content: `You are an AI tutor for neurodivergent students. Be patient, clear, and adapt to a '${userReadingLevel}' reading level. Be proactive in offering alternative explanations if the student seems to struggle.` },
          { role: 'user', content: prompt }
        ],
        max_tokens: 350, // Adjust token limit as needed
        temperature: 0.5, // Adjust for creativity vs. factuality
      },
      {
        headers: {
          'Authorization': `Bearer ${OPENROUTER_API_KEY}`,
          'Content-Type': 'application/json',
          'HTTP-Referer': YOUR_SITE_URL,
          'X-Title': YOUR_SITE_NAME
        }
      }
    );
    const durationMs = Date.now() - startTime;

    if (!response.data || !response.data.choices || response.data.choices.length === 0 || !response.data.choices[0].message) {
        console.error("Invalid response structure from OpenRouter API:", response.data);
        return res.status(502).json({ error: 'Received an invalid or empty response from the AI service.' });
    }

    const answer = response.data.choices[0].message.content.trim();

    await Session.findOneAndUpdate(
        { userId: userId },
        {
            $push: {
                interactions: {
                    question: question,
                    answer: answer,
                    topic: contentDoc?.topic || topic, // Use actual slug from content if available
                    contextUsed: contextUsed,
                    modeUsed: 'qa',
                    durationMs: durationMs,
                    timestamp: new Date()
                }
            },
            $set: { lastActivityAt: new Date() },
            $setOnInsert: { createdAt: new Date() }
        },
        { upsert: true, new: true }
    );

    res.json({ answer });

  } catch (err) {
    console.error("Error in askQuestion:", err.response ? JSON.stringify(err.response.data, null, 2) : err.message, err.stack);
    let statusCode = 500;
    let errorMessage = err.message || 'Failed to get answer from AI service.';
    if (err.response) {
        statusCode = err.response.status || 500;
        errorMessage = err.response.data?.error?.message || err.response.data?.error || errorMessage;
        if (statusCode === 401) errorMessage = "AI service authentication failed. Check API key.";
        if (statusCode === 429) errorMessage = "AI service rate limit exceeded. Please try again later.";
    }
    res.status(statusCode).json({ error: errorMessage });
  }
};

===== File: /controllers/taskController.js =====
// ===== File: /controllers/taskController.js =====
const UserTask = require('../models/UserTask');
const Content = require('../models/Content'); // To validate contentId if provided
const { validationResult, body } = require('express-validator');

exports.taskValidation = [
    body('title').trim().isLength({ min: 1 }).withMessage('Title is required.'),
    body('description').optional().trim(),
    body('relatedContentId').optional().isMongoId().withMessage('Invalid content ID format.'),
    body('dueDate').optional().isISO8601().toDate().withMessage('Invalid due date format.'),
    body('completed').optional().isBoolean().withMessage('Completed must be a boolean.'),
    body('priority').optional().isIn(['low', 'medium', 'high']).withMessage('Invalid priority value.')
];

exports.createTask = async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
    }

    try {
        const { title, description, relatedContentId, dueDate, priority } = req.body;
        const userId = req.user._id;

        let relatedContentTopic;
        if (relatedContentId) {
            const content = await Content.findById(relatedContentId).select('topic');
            if (!content) {
                return res.status(404).json({ error: 'Related content not found.' });
            }
            relatedContentTopic = content.topic;
        }

        const task = new UserTask({
            userId,
            title,
            description,
            relatedContentId,
            relatedContentTopic,
            dueDate,
            priority
        });

        await task.save();
        res.status(201).json(task);
    } catch (error) {
        console.error('Create Task Error:', error);
        res.status(500).json({ error: 'Failed to create task.' });
    }
};

exports.getUserTasks = async (req, res) => {
    try {
        const userId = req.user._id;
        const { completed, priority, sortBy = 'createdAt:desc', relatedContentId } = req.query;

        const query = { userId };
        if (completed !== undefined) {
            query.completed = completed === 'true';
        }
        if (priority) {
            query.priority = priority;
        }
        if (relatedContentId) {
            query.relatedContentId = relatedContentId;
        }

        const sortOptions = {};
        if (sortBy) {
            const parts = sortBy.split(':');
            sortOptions[parts[0]] = parts[1] === 'desc' ? -1 : 1;
        }


        const tasks = await UserTask.find(query).sort(sortOptions);
        res.json(tasks);
    } catch (error) {
        console.error('Get User Tasks Error:', error);
        res.status(500).json({ error: 'Failed to retrieve tasks.' });
    }
};

exports.getTaskById = async (req, res) => {
    try {
        const taskId = req.params.id;
        const userId = req.user._id;

        const task = await UserTask.findOne({ _id: taskId, userId });
        if (!task) {
            return res.status(404).json({ error: 'Task not found or not authorized.' });
        }
        res.json(task);
    } catch (error) {
        if (error.kind === 'ObjectId') {
            return res.status(400).json({ error: 'Invalid task ID format.' });
        }
        console.error('Get Task By ID Error:', error);
        res.status(500).json({ error: 'Failed to retrieve task.' });
    }
};

exports.updateTask = async (req, res) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
    }

    try {
        const taskId = req.params.id;
        const userId = req.user._id;
        const { title, description, relatedContentId, dueDate, completed, priority } = req.body;

        const task = await UserTask.findOne({ _id: taskId, userId });
        if (!task) {
            return res.status(404).json({ error: 'Task not found or not authorized.' });
        }

        if (title) task.title = title;
        if (description !== undefined) task.description = description;
        if (dueDate !== undefined) task.dueDate = dueDate; // Allow null to clear date
        if (completed !== undefined) task.completed = completed;
        if (priority) task.priority = priority;

        if (relatedContentId !== undefined) { // Allows setting to null or new ID
            if (relatedContentId) {
                const content = await Content.findById(relatedContentId).select('topic');
                if (!content) {
                    return res.status(404).json({ error: 'Related content not found.' });
                }
                task.relatedContentId = relatedContentId;
                task.relatedContentTopic = content.topic;
            } else {
                task.relatedContentId = undefined;
                task.relatedContentTopic = undefined;
            }
        }


        await task.save();
        res.json(task);
    } catch (error) {
        if (error.kind === 'ObjectId') {
            return res.status(400).json({ error: 'Invalid task ID format.' });
        }
        console.error('Update Task Error:', error);
        res.status(500).json({ error: 'Failed to update task.' });
    }
};

exports.deleteTask = async (req, res) => {
    try {
        const taskId = req.params.id;
        const userId = req.user._id;

        const task = await UserTask.findOneAndDelete({ _id: taskId, userId });
        if (!task) {
            return res.status(404).json({ error: 'Task not found or not authorized.' });
        }
        res.json({ message: 'Task deleted successfully.' });
    } catch (error) {
        if (error.kind === 'ObjectId') {
            return res.status(400).json({ error: 'Invalid task ID format.' });
        }
        console.error('Delete Task Error:', error);
        res.status(500).json({ error: 'Failed to delete task.' });
    }
};


// --- User Learning Progress Endpoints ---
const UserLearningProgress = require('../models/UserLearningProgress');

exports.getLearningProgressForContent = async (req, res) => {
    try {
        const userId = req.user._id;
        const { contentId } = req.params;

        if (!mongoose.Types.ObjectId.isValid(contentId)) {
            return res.status(400).json({ error: 'Invalid content ID format.' });
        }

        const progress = await UserLearningProgress.findOne({ userId, contentId });
        if (!progress) {
            // Return a default structure or 204 No Content, or 404 if preferred
            return res.status(200).json({
                userId,
                contentId,
                status: 'not_started',
                timeSpentTotalMs: 0,
                modesUsedFrequency: [],
                lastAccessed: null
            });
        }
        res.json(progress);
    } catch (error) {
        console.error("Error fetching learning progress:", error);
        res.status(500).json({ error: "Failed to fetch learning progress." });
    }
};

exports.getRecentLearningActivity = async (req, res) => {
    try {
        const userId = req.user._id;
        const limit = parseInt(req.query.limit) || 5;

        const recentProgress = await UserLearningProgress.find({ userId, status: { $in: ['in_progress', 'completed'] } })
            .sort({ lastAccessed: -1 })
            .limit(limit)
            .populate('contentId', 'topic originalText tags'); // Populate with content details

        res.json(recentProgress);
    } catch (error) {
        console.error("Error fetching recent learning activity:", error);
        res.status(500).json({ error: "Failed to fetch recent activity." });
    }
};


exports.logContentInteraction = async (req, res) => {
    const { contentId, mode, eventType, durationMs } = req.body; // eventType: 'start' or 'end'
    const userId = req.user._id;

    if (!mongoose.Types.ObjectId.isValid(contentId)) {
        return res.status(400).json({ error: 'Invalid content ID.' });
    }
    if (!mode || typeof mode !== 'string') {
        return res.status(400).json({ error: 'Mode is required.' });
    }
    if (!['start', 'end'].includes(eventType)) {
        return res.status(400).json({ error: 'Invalid eventType. Must be "start" or "end".' });
    }

    try {
        let progress;
        if (eventType === 'start') {
            progress = await UserLearningProgress.logInteractionStart(userId, contentId, mode);
        } else if (eventType === 'end') {
            if (typeof durationMs !== 'number' || durationMs < 0) {
                return res.status(400).json({ error: 'Valid durationMs is required for "end" event.' });
            }
            progress = await UserLearningProgress.logInteractionEnd(userId, contentId, durationMs);
        }

        if (!progress && eventType === 'end') {
            // This case is handled inside logInteractionEnd, but good to be aware
            return res.status(200).json({ message: "Interaction end logged, but no active start found or duration insignificant." });
        }
        if (!progress) {
            return res.status(404).json({error: "Could not find or update learning progress."})
        }

        res.status(200).json({ message: `Interaction ${eventType} logged successfully.`, progress });
    } catch (error) {
        console.error('Error logging content interaction:', error);
        res.status(500).json({ error: 'Failed to log content interaction.' });
    }
};

===== File: /controllers/userController.js =====
// ===== File: /controllers/userController.js =====
const User = require('../models/User');
const mongoose = require('mongoose');
const logAction = require('../utils/auditLogger');

exports.getAllUsers = async (req, res) => {
    try {
        const page = parseInt(req.query.page) || 1;
        const limit = parseInt(req.query.limit) || 10;
        const skip = (page - 1) * limit;

        const query = {};
        if (req.query.search && req.query.search.trim() !== '') {
            const searchRegex = new RegExp(req.query.search.trim(), 'i');
            query.$or = [ { name: searchRegex }, { email: searchRegex } ];
        }
        if (req.query.role && ['user', 'creator', 'admin'].includes(req.query.role)) {
            query.role = req.query.role;
        }

        const sortOptions = {};
        if (req.query.sortBy) {
            const parts = req.query.sortBy.split(':');
            sortOptions[parts[0]] = parts[1] === 'desc' ? -1 : 1;
        } else {
            sortOptions.createdAt = -1;
        }

        const users = await User.find(query)
            .select('-password')
            .sort(sortOptions)
            .skip(skip)
            .limit(limit);

        const totalUsers = await User.countDocuments(query);
        const totalPages = Math.ceil(totalUsers / limit);

        res.json({ users, currentPage: page, totalPages, totalUsers });
    } catch (error) {
        console.error("Get All Users Error:", error);
        res.status(500).json({ error: 'Server error fetching users' });
    }
};

exports.getUserById = async (req, res) => {
    try {
        if (!mongoose.Types.ObjectId.isValid(req.params.id)) {
            return res.status(400).json({ error: 'Invalid user ID format' });
        }
        const user = await User.findById(req.params.id).select('-password');
        if (!user) { return res.status(404).json({ error: 'User not found' }); }
        res.json(user);
    } catch (error) {
        console.error("Get User By ID Error:", error);
        res.status(500).json({ error: 'Server error fetching user' });
    }
};

exports.updateUserRole = async (req, res) => {
    try {
        if (!mongoose.Types.ObjectId.isValid(req.params.id)) {
            return res.status(400).json({ error: 'Invalid user ID format' });
        }
        const { role } = req.body;
        if (!['user', 'creator', 'admin'].includes(role)) {
            return res.status(400).json({ error: 'Invalid role specified' });
        }

        const user = await User.findById(req.params.id);
        if (!user) { return res.status(404).json({ error: 'User not found' }); }

        if (user.id.toString() === req.user.id && user.role === 'admin' && role !== 'admin') {
            const adminCount = await User.countDocuments({ role: 'admin' });
            if (adminCount <= 1) {
                return res.status(400).json({ error: 'Cannot remove the last admin role.' });
            }
        }
        
        const oldRole = user.role;
        if (oldRole === role) { // No change
             const userToReturn = user.toObject();
             delete userToReturn.password;
             return res.json(userToReturn);
        }
        user.role = role;
        await user.save();
        
        await logAction(
            req.user.id, 
            'UPDATE_USER_ROLE',
            'User',
            user._id, 
            { targetUserId: user._id.toString(), targetUserEmail: user.email, oldRole: oldRole, newRole: role },
            req.ip
        );

        const userToReturn = user.toObject();
        delete userToReturn.password;
        res.json(userToReturn);
    } catch (error) {
        console.error("Update User Role Error:", error);
        res.status(500).json({ error: 'Server error updating user role' });
    }
};

exports.deleteUserCtrl = async (req, res) => {
    try {
        if (!mongoose.Types.ObjectId.isValid(req.params.id)) {
            return res.status(400).json({ error: 'Invalid user ID format' });
        }
        const userToDelete = await User.findById(req.params.id); // Renamed variable
        if (!userToDelete) { return res.status(404).json({ error: 'User not found' }); }

        if (req.user.id === userToDelete.id.toString()) {
             return res.status(400).json({ error: 'Admin cannot delete themselves.' });
        }
        
        const deletedUserEmail = userToDelete.email;
        const deletedUserId = userToDelete._id.toString(); // Capture ID before deletion
        await userToDelete.deleteOne(); 
        
        await logAction(
            req.user.id, 
            'DELETE_USER',
            'User',
            deletedUserId, // Use the string ID here for consistency if entityId is not always ObjectId
            { targetUserId: deletedUserId, targetUserEmail: deletedUserEmail },
            req.ip
        );

        res.json({ message: 'User removed successfully' });
    } catch (error) {
        console.error("Delete User Error:", error);
        res.status(500).json({ error: 'Server error deleting user' });
    }
};

===== File: /models/AuditLog.js =====
// ===== File: /models/AuditLog.js =====
const mongoose = require('mongoose');

const auditLogSchema = new mongoose.Schema({
  user: { 
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  action: { 
    type: String,
    required: true
  },
  entity: { 
    type: String,
    required: true
  },
  entityId: { 
    type: mongoose.Schema.Types.ObjectId,
  },
  details: { 
    type: mongoose.Schema.Types.Mixed 
  },
  ipAddress: { 
    type: String
  },
  timestamp: {
    type: Date,
    default: Date.now
  }
});

module.exports = mongoose.model('AuditLog', auditLogSchema);

===== File: /models/Content.js =====
const mongoose = require('mongoose');

const simplifiedSchema = new mongoose.Schema({
  level: {
    type: String,
    // Updated enum for granular simplification
    enum: ['eli5', 'easy', 'moderate', 'advanced', 'high_school', 'college_intro'],
    required: true
  },
  text: { type: String },
  createdAt: { type: Date, default: Date.now }
}, { _id: false });

const visualMapSchema = new mongoose.Schema({
  format: { type: String, enum: ['mermaid', 'json_graph', 'text_outline'], default: 'text_outline' },
  data: { type: String, required: true },
  notes: String,
  createdAt: { type: Date, default: Date.now }
}, { _id: false });


const contentSchema = new mongoose.Schema({
  topic: {
    type: String,
    required: true,
    unique: true,
    lowercase: true,
    trim: true
  },
  originalText: {
    type: String,
    required: true
  },
  simplifiedVersions: [simplifiedSchema],
  visualMaps: [visualMapSchema],
  audioNarrations: [
    {
      language: { type: String, default: 'en-US' },
      voice: { type: String, default: 'default' },
      url: { type: String, required: true },
      createdAt: { type: Date, default: Date.now }
    }
  ],
  videoExplainers: [
    {
      source: { type: String, enum: ['youtube', 'vimeo', 'custom_upload', 'generated'], default: 'youtube' },
      url: { type: String, required: true },
      title: String,
      description: String,
      createdAt: { type: Date, default: Date.now }
    }
  ],
  tags: [String],
  media: {
    imageUrls: [String],
  },
  learningObjectives: [String], // NEW: for educators to specify
  keyVocabulary: [String], // NEW: for educators

  createdBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
  },
  lastUpdatedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  createdAt: {
    type: Date,
    default: Date.now
  },
  updatedAt: {
    type: Date,
    default: Date.now
  }
});

contentSchema.pre('save', function(next) {
  if (this.isModified()) {
    this.updatedAt = Date.now();
  }
  next();
});

module.exports = mongoose.model('Content', contentSchema);

===== File: /models/Course.js =====
// ===== File: /models/Course.js =====
const mongoose = require('mongoose');
const Module = require('./Module'); // Required for cascading delete

const courseSchema = new mongoose.Schema({
  title: {
    type: String,
    required: true,
    trim: true,
  },
  description: {
    type: String,
    trim: true,
  },
  slug: {
    type: String,
    required: true,
    unique: true,
    lowercase: true,
    trim: true,
  },
  instructorIds: [{
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
  }],
  studentIds: [{ // For enrollment
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
  }],
  modules: [{ // Ordered list of Module ObjectIds
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Module',
  }],
  published: {
    type: Boolean,
    default: false,
  },
  coverImage: {
    type: String, // URL to the image
    trim: true,
  },
  category: {
    type: String,
    trim: true,
  },
  globalLearningObjectives: [String],
  createdBy: { // Track who originally created the course
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
  },
  lastUpdatedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
  }
}, { timestamps: true });

// Middleware to generate slug from title before saving
courseSchema.pre('validate', function(next) {
  if (this.title && (this.isModified('title') || this.isNew)) {
    this.slug = this.title.toLowerCase().trim().replace(/\s+/g, '-').replace(/[^\w-]+/g, '');
  }
  next();
});

// Ensure an instructor is added when createdBy is set
courseSchema.pre('save', function(next) {
    if (this.isNew && this.createdBy && !this.instructorIds.map(id => id.toString()).includes(this.createdBy.toString())) {
        this.instructorIds.push(this.createdBy);
    }
    if (this.isModified() && this.lastUpdatedBy) {
        // This timestamp is automatically handled by Mongoose {timestamps: true}
    }
    next();
});

// Middleware for cascading delete of modules when a course is removed
courseSchema.pre('remove', async function(next) {
    try {
        // 'this' refers to the course document being removed
        await Module.deleteMany({ courseId: this._id });
        // Note: This will trigger 'remove' hooks on Module schema if defined
        next();
    } catch (error) {
        next(error);
    }
});


module.exports = mongoose.model('Course', courseSchema);

===== File: /models/Lesson.js =====
// ===== File: /models/Lesson.js =====
const mongoose = require('mongoose');

const lessonItemSchema = new mongoose.Schema({
  itemType: {
    type: String,
    enum: ['Content', 'Quiz', 'Assignment', 'ExternalLink', 'Discussion'], // Add more as needed
    required: true,
  },
  itemId: {
    type: mongoose.Schema.Types.ObjectId,
    required: true,
    refPath: 'items.itemType', // Dynamic ref based on itemType
  },
  titleOverride: { // Optional, to display a different title for this item in the lesson context
    type: String,
    trim: true,
  },
  order: {
      type: Number,
      required: true,
      default: 0
  }
}, { _id: false }); // No separate _id for subdocuments unless needed

const lessonSchema = new mongoose.Schema({
  title: {
    type: String,
    required: true,
    trim: true,
  },
  moduleId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Module',
    required: true,
    index: true,
  },
  order: { // For sequencing within a module
    type: Number,
    required: true,
    default: 0,
  },
  items: [lessonItemSchema], // Ordered list of items
  published: {
    type: Boolean,
    default: false,
  },
  estimatedCompletionTimeMinutes: {
    type: Number,
    min: 0,
  },
  createdBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
  },
  lastUpdatedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
  }
}, { timestamps: true });

// No specific 'remove' hook for Lesson needed for now, as its items are references.
// If items were actual subdocuments that needed cleanup, a hook might be relevant.

module.exports = mongoose.model('Lesson', lessonSchema);

===== File: /models/Module.js =====
// ===== File: /models/Module.js =====
const mongoose = require('mongoose');
const Lesson = require('./Lesson'); // Required for cascading delete

const moduleSchema = new mongoose.Schema({
  title: {
    type: String,
    required: true,
    trim: true,
  },
  description: {
    type: String,
    trim: true,
  },
  courseId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Course',
    required: true,
    index: true,
  },
  order: { // For sequencing within a course
    type: Number,
    required: true,
    default: 0,
  },
  lessons: [{ // Ordered list of Lesson ObjectIds
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Lesson',
  }],
  published: {
    type: Boolean,
    default: false,
  },
  moduleLearningObjectives: [String],
  createdBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true,
  },
  lastUpdatedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
  }
}, { timestamps: true });


// Middleware for cascading delete of lessons when a module is removed
moduleSchema.pre('remove', async function(next) {
    try {
        // 'this' refers to the module document being removed
        await Lesson.deleteMany({ moduleId: this._id });
        // Note: This will trigger 'remove' hooks on Lesson schema if defined
        next();
    } catch (error) {
        next(error);
    }
});

module.exports = mongoose.model('Module', moduleSchema);

===== File: /models/Session.js =====
// ===== File: /models/Session.js =====
const mongoose = require('mongoose');

const interactionSchema = new mongoose.Schema({
  question: String,
  answer: String,
  topic: String, // Existing
  contextUsed: String, // Existing e.g., 'original', 'simplified_easy', 'general_knowledge'
  modeUsed: String, // NEW: e.g., 'qa', 'simplification_request', 'visual_map_request'
  durationMs: Number, // NEW: Time spent on this specific interaction if applicable
  timestamp: { type: Date, default: Date.now }
}, { _id: false });

const sessionSchema = new mongoose.Schema({
  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  interactions: [interactionSchema], // Updated schema for interactions
  createdAt: { type: Date, default: Date.now },
  lastActivityAt: { type: Date, default: Date.now } // NEW: To track active sessions
});

// Update lastActivityAt on modification of interactions
sessionSchema.pre('findOneAndUpdate', function(next) {
  if (this.getUpdate().$push && this.getUpdate().$push.interactions) {
    this.getUpdate().lastActivityAt = new Date();
  }
  next();
});


module.exports = mongoose.model('Session', sessionSchema);

===== File: /models/User.js =====
// ===== File: /models/User.js =====
const mongoose = require('mongoose');
const bcrypt = require('bcrypt');

const userSchema = new mongoose.Schema({
  name: { type: String },
  email: { type: String, required: true, unique: true, lowercase: true, trim: true },
  password: { type: String, required: true },

  role: {
    type: String,
    enum: ['user', 'creator', 'admin'], // Added 'creator'
    default: 'user'
  },

  preferences: {
    readingLevel: { type: String, default: 'basic', enum: ['basic', 'intermediate', 'advanced'] },
    fontSize: { type: String, default: 'medium', enum: ['small', 'medium', 'large', 'xlarge'] },
    theme: { type: String, default: 'light', enum: ['light', 'dark', 'high-contrast'] },
    dyslexiaFontEnabled: { type: Boolean, default: false },
    preferredContentMode: { type: String, default: 'text', enum: ['text', 'video', 'visual', 'audio']},
    ttsEnabled: { type: Boolean, default: false }
  },

  createdAt: { type: Date, default: Date.now }
});

// ... rest of the User model (pre-save hook, matchPassword method) ...
userSchema.pre('save', async function (next) {
  if (!this.isModified('password')) return next();
  const salt = await bcrypt.genSalt(10);
  this.password = await bcrypt.hash(this.password, salt);
  next();
});

userSchema.methods.matchPassword = async function (enteredPassword) {
  return await bcrypt.compare(enteredPassword, this.password);
};

module.exports = mongoose.model('User', userSchema);

===== File: /models/UserLearningProgress.js =====
// ===== File: /models/UserLearningProgress.js =====
const mongoose = require('mongoose');

const modeUsageSchema = new mongoose.Schema({
    mode: { type: String, required: true }, // e.g., 'original', 'simplified_easy', 'simplified_moderate', 'visual_mermaid', 'audio'
    count: { type: Number, default: 0 },
    totalTimeSpentMs: { type: Number, default: 0 }
}, { _id: false });

const userLearningProgressSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  contentId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Content',
    required: true
  },
  status: {
    type: String,
    enum: ['not_started', 'in_progress', 'completed', 'bookmarked'],
    default: 'not_started'
  },
  lastAccessed: {
    type: Date,
    default: Date.now
  },
  timeSpentTotalMs: { // Total time spent on this content across all sessions/modes
    type: Number,
    default: 0
  },
  modesUsedFrequency: [modeUsageSchema], // Tracks how often and for how long each mode is used for this content
  // For future micro-assessments:
  // quizScores: [{
  //   quizId: String, // Could be an ObjectId if quizzes become separate models
  //   score: Number,
  //   attempts: Number,
  //   lastAttempted: Date
  // }],
  notes: String, // User's personal notes on this content topic
  currentInteractionData: { // Data from client-side tracking for the current interaction with content
    mode: String,
    startTime: Date,
  }
}, { timestamps: true }); // Adds createdAt and updatedAt

// Compound index for efficient querying
userLearningProgressSchema.index({ userId: 1, contentId: 1 }, { unique: true });
userLearningProgressSchema.index({ userId: 1, status: 1 });
userLearningProgressSchema.index({ userId: 1, lastAccessed: -1 });


userLearningProgressSchema.statics.logInteractionStart = async function(userId, contentId, mode) {
    return this.findOneAndUpdate(
        { userId, contentId },
        {
            $set: {
                status: 'in_progress',
                lastAccessed: new Date(),
                'currentInteractionData.mode': mode,
                'currentInteractionData.startTime': new Date()
            }
        },
        { upsert: true, new: true }
    );
};

userLearningProgressSchema.statics.logInteractionEnd = async function(userId, contentId, durationMs) {
    const progress = await this.findOne({ userId, contentId });
    if (!progress || !progress.currentInteractionData || !progress.currentInteractionData.mode || !progress.currentInteractionData.startTime) {
        // console.warn(`No active interaction found for user ${userId} on content ${contentId} to log end.`);
        // If no start, maybe just update total time if duration is significant
        if (durationMs > 1000) { // only log if more than a second
             await this.findOneAndUpdate(
                { userId, contentId },
                {
                    $inc: { timeSpentTotalMs: durationMs },
                    $set: { lastAccessed: new Date(), status: 'in_progress' } // ensure status is in_progress
                },
                { upsert: true }
            );
        }
        return null;
    }

    const mode = progress.currentInteractionData.mode;
    // const startTime = progress.currentInteractionData.startTime;
    // const actualDurationMs = new Date().getTime() - startTime.getTime(); // Can use this or client-provided

    const updateQuery = {
        $inc: {
            timeSpentTotalMs: durationMs,
        },
        $set: {
            lastAccessed: new Date(),
            currentInteractionData: {} // Clear current interaction
        }
    };

    // Update modesUsedFrequency
    const modeUsageIndex = progress.modesUsedFrequency.findIndex(m => m.mode === mode);
    if (modeUsageIndex > -1) {
        updateQuery.$inc[`modesUsedFrequency.${modeUsageIndex}.count`] = 1;
        updateQuery.$inc[`modesUsedFrequency.${modeUsageIndex}.totalTimeSpentMs`] = durationMs;
    } else {
        updateQuery.$push = {
            modesUsedFrequency: { mode, count: 1, totalTimeSpentMs: durationMs }
        };
    }

    return this.findOneAndUpdate(
        { userId, contentId },
        updateQuery,
        { new: true }
    );
};


module.exports = mongoose.model('UserLearningProgress', userLearningProgressSchema);

===== File: /models/UserTask.js =====
// ===== File: /models/UserTask.js =====
const mongoose = require('mongoose');

const userTaskSchema = new mongoose.Schema({
  userId: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  title: {
    type: String,
    required: true,
    trim: true
  },
  description: {
    type: String,
    trim: true
  },
  relatedContentId: { // Optional: link task to a specific content item
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Content'
  },
  relatedContentTopic: String, // Store topic slug for easy display if content is linked
  dueDate: {
    type: Date
  },
  completed: {
    type: Boolean,
    default: false
  },
  completedAt: {
    type: Date
  },
  priority: {
    type: String,
    enum: ['low', 'medium', 'high'],
    default: 'medium'
  },
  // For future Pomodoro integration:
  // pomodorosEstimated: Number,
  // pomodorosCompleted: { type: Number, default: 0 }
}, { timestamps: true }); // Adds createdAt and updatedAt

userTaskSchema.index({ userId: 1, completed: 1, dueDate: 1 });

userTaskSchema.pre('save', function(next) {
  if (this.isModified('completed') && this.completed && !this.completedAt) {
    this.completedAt = new Date();
  } else if (this.isModified('completed') && !this.completed) {
    this.completedAt = undefined;
  }
  next();
});

module.exports = mongoose.model('UserTask', userTaskSchema);

===== File: /routes/authRoutes.js =====
const express = require('express');
const router = express.Router();
const { signup, login, getMe, updatePreferences, signupValidation, loginValidation } = require('../controllers/authController');
const { protect } = require('../middleware/authMiddleware');

router.post('/signup', signupValidation, signup);
router.post('/login', loginValidation, login);
router.get('/me', protect, getMe); // New route to get current user profile
router.put('/preferences', protect, updatePreferences); // New route to update preferences

module.exports = router;

===== File: /routes/contentRoutes.js =====
// ===== File: /server/routes/contentRoutes.js =====
const express = require('express');
const router = express.Router();
const contentController = require('../controllers/contentController');
const { protect, isAdmin, isCreatorOrAdmin } = require('../middleware/authMiddleware'); // Import isCreatorOrAdmin

// --- Routes for general users (protected) ---
router.get('/', protect, contentController.getAllContent); // For dashboard topic list
router.get('/topic/:topic', protect, contentController.getContentByTopic);
router.post('/simplify', protect, contentController.simplifyContent);
router.post('/visual-map', protect, contentController.generateVisualMap);
// Add routes for audio/video generation/sourcing for users later if needed

// --- CRUD Routes for Content (Protected, Creator or Admin) ---
router.post('/create', protect, isCreatorOrAdmin, contentController.createContent);
// Admin or Creator can get by ID for management/editing
router.get('/:id', protect, isCreatorOrAdmin, contentController.getContentById); 
router.put('/:id', protect, isCreatorOrAdmin, contentController.updateContent);
router.delete('/:id', protect, isCreatorOrAdmin, contentController.deleteContent);

// --- Routes for Audio/Video generation (Creator or Admin-focused initially) ---
router.post('/generate-audio', protect, isCreatorOrAdmin, contentController.generateAudioNarration);
router.post('/find-videos', protect, isCreatorOrAdmin, contentController.findVideoExplainers);


module.exports = router;

===== File: /routes/courseRoutes.js =====
// ===== File: /routes/courseRoutes.js =====
const express = require('express');
const router = express.Router();
const courseController = require('../controllers/courseController');
const { protect, isCreatorOrAdmin, isAdmin } = require('../middleware/authMiddleware');

// --- Course CRUD & Management (Admin/Creator/Instructor) ---
router.post('/', protect, isCreatorOrAdmin, courseController.courseCreateValidation, courseController.createCourse);
router.get('/', protect, courseController.getAllCourses); // Public view filtered, admin/creator see all
router.get('/identifier/:identifier', protect, courseController.getCourseByIdOrSlug); // Use "identifier" to fetch by ID or slug
router.put('/:id', protect, isCreatorOrAdmin, courseController.courseCreateValidation, courseController.updateCourse); // Auth inside controller
router.delete('/:id', protect, isAdmin, courseController.deleteCourse); // Stricter delete permission

// --- Student Enrollment ---
router.post('/:id/enroll', protect, courseController.enrollInCourse);
router.delete('/:id/unenroll', protect, courseController.unenrollFromCourse);
router.get('/me/enrolled', protect, courseController.getEnrolledCourses);


// --- Module Management within a Course (Admin/Creator/Instructor) ---
// These could also be nested: router.post('/:courseId/modules', ...)
router.post('/:courseId/modules/add', protect, isCreatorOrAdmin, courseController.addModuleToCourse); // Auth inside controller for instructor check
router.put('/:courseId/modules/reorder', protect, isCreatorOrAdmin, courseController.updateModulesOrderInCourse); // Auth inside controller

module.exports = router;

===== File: /routes/lessonRoutes.js =====
// ===== File: /routes/lessonRoutes.js =====
const express = require('express');
const router = express.Router();
const lessonController = require('../controllers/lessonController');
const { protect, isCreatorOrAdmin } = require('../middleware/authMiddleware');

// Create a new lesson (implicitly links to module passed in body)
router.post('/', protect, isCreatorOrAdmin, lessonController.lessonCreateValidation, lessonController.createLesson);

// Get all lessons for a specific module
router.get('/byModule/:moduleId', protect, lessonController.getLessonsByModule);

// Get a specific lesson by its ID
router.get('/:id', protect, lessonController.getLessonById);

// Update a lesson
router.put('/:id', protect, isCreatorOrAdmin, lessonController.lessonCreateValidation, lessonController.updateLesson); // Auth inside controller

// Delete a lesson
router.delete('/:id', protect, isCreatorOrAdmin, lessonController.deleteLesson); // Auth inside controller

// --- Lesson Item Management ---
router.post('/:lessonId/items/add', protect, isCreatorOrAdmin, lessonController.lessonItemValidation, lessonController.addItemToLesson);
router.delete('/:lessonId/items/remove', protect, isCreatorOrAdmin, lessonController.removeItemFromLesson); // itemId and itemType in body
router.put('/:lessonId/items/reorder', protect, isCreatorOrAdmin, lessonController.updateLessonItemsOrder);


module.exports = router;

===== File: /routes/moduleRoutes.js =====
// ===== File: /routes/moduleRoutes.js =====
const express = require('express');
const router = express.Router();
const moduleController = require('../controllers/moduleController');
const { protect, isCreatorOrAdmin } = require('../middleware/authMiddleware');

// Create a new module (implicitly links to course passed in body, or could be /courses/:courseId/modules)
router.post('/', protect, isCreatorOrAdmin, moduleController.moduleCreateValidation, moduleController.createModule);

// Get all modules for a specific course
router.get('/byCourse/:courseId', protect, moduleController.getModulesByCourse);

// Get a specific module by its ID
router.get('/:id', protect, moduleController.getModuleById);

// Update a module
router.put('/:id', protect, isCreatorOrAdmin, moduleController.moduleCreateValidation, moduleController.updateModule); // Auth inside controller

// Delete a module
router.delete('/:id', protect, isCreatorOrAdmin, moduleController.deleteModule); // Auth inside controller

// --- Lesson Management within a Module ---
router.post('/:moduleId/lessons/add', protect, isCreatorOrAdmin, moduleController.addLessonToModule); // Auth inside controller
router.put('/:moduleId/lessons/reorder', protect, isCreatorOrAdmin, moduleController.updateLessonsOrderInModule); // Auth inside controller

module.exports = router;

===== File: /routes/qaRoutes.js =====
// ===== File: /routes/qaRoutes.js =====
const express = require('express');
const router = express.Router();
const qaController = require('../controllers/qaController');
const { protect } = require('../middleware/authMiddleware'); // Import middleware

// POST a question - Requires user to be logged in
router.post('/ask', protect, qaController.askQuestion);

module.exports = router;

===== File: /routes/taskRoutes.js =====
// ===== File: /routes/taskRoutes.js =====
const express = require('express');
const router = express.Router();
const {
    createTask,
    getUserTasks,
    getTaskById,
    updateTask,
    deleteTask,
    taskValidation,
    getLearningProgressForContent, // Added
    getRecentLearningActivity,   // Added
    logContentInteraction        // Added
} = require('../controllers/taskController'); // taskController now holds these too
const { protect } = require('../middleware/authMiddleware');

router.use(protect); // All task routes are protected

// Task Management
router.post('/', taskValidation, createTask);
router.get('/', getUserTasks);
router.get('/:id', getTaskById);
router.put('/:id', taskValidation, updateTask);
router.delete('/:id', deleteTask);

// Learning Progress & Interaction Logging (could be in a separate progressRoutes.js too)
router.get('/progress/content/:contentId', getLearningProgressForContent);
router.get('/progress/recent', getRecentLearningActivity);
router.post('/progress/log-interaction', logContentInteraction);


module.exports = router;

===== File: /routes/userRoutes.js =====
// ===== File: /routes/userRoutes.js =====
const express = require('express');
const router = express.Router();
const { getAllUsers, getUserById, updateUserRole, deleteUserCtrl } = require('../controllers/userController');
const { protect, isAdmin } = require('../middleware/authMiddleware');

// All user management routes are admin-only
router.use(protect);
router.use(isAdmin);

router.get('/', getAllUsers);
router.get('/:id', getUserById);
router.put('/:id/role', updateUserRole); // Specific endpoint for updating role
router.delete('/:id', deleteUserCtrl);

module.exports = router;

===== File: /app.js =====
// ===== File: /app.js =====
const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const helmet = require('helmet'); // For security headers
const morgan = require('morgan'); // For request logging

require('dotenv').config();

// --- Environment Variable Check ---
const requiredEnvVars = [
  'MONGO_URI',
  'JWT_SECRET',
  'OPENROUTER_API_KEY',
  'GOOGLE_API_KEY', // Ensure this is checked if not already
  // 'YOUR_SITE_URL', // Recommended, but provide defaults in controllers if not set
  // 'YOUR_SITE_NAME', // Recommended, but provide defaults if not set
  // 'OPENROUTER_DEFAULT_MODEL' // Has a default in controllers
];
for (const envVar of requiredEnvVars) {
  if (!process.env[envVar]) {
    console.error(`FATAL ERROR: Environment variable ${envVar} is not defined.`);
    process.exit(1);
  }
}

const app = express();

// --- Middleware ---
const corsOptions = {
  origin: [
    "http://127.0.0.1:3000",
    "http://localhost:3000",
    "http://[::1]:3000",
    process.env.FRONTEND_URL,
    "https://opulent-garbanzo-975vgqvp4jj4cg6x-3000.app.github.dev"
  ].filter(Boolean),
  credentials: true,
  methods: "GET,HEAD,PUT,PATCH,POST,DELETE",
  preflightContinue: false,
  optionsSuccessStatus: 200
};
app.use(cors(corsOptions));
app.use(helmet());
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

if (process.env.NODE_ENV === 'development') {
  app.use(morgan('dev'));
}

// --- Routes ---
const authRoutes = require('./routes/authRoutes');
const contentRoutes = require('./routes/contentRoutes');
const qaRoutes = require('./routes/qaRoutes');
const userRoutes = require('./routes/userRoutes');
const taskRoutes = require('./routes/taskRoutes'); // Includes learning progress routes
const courseRoutes = require('./routes/courseRoutes');
const moduleRoutes = require('./routes/moduleRoutes');
const lessonRoutes = require('./routes/lessonRoutes');
app.use('/api/auth', authRoutes);
app.use('/api/content', contentRoutes);
app.use('/api/qa', qaRoutes);
app.use('/api/users', userRoutes);
app.use('/api/tasks', taskRoutes); // All task and learning progress related routes
app.use('/api/courses', courseRoutes);
app.use('/api/modules', moduleRoutes);
app.use('/api/lessons', lessonRoutes);

// --- Database Connection ---
mongoose.connect(process.env.MONGO_URI)
  .then(() => console.log("MongoDB connected successfully."))
  .catch(err => {
    console.error("MongoDB connection error:", err.message);
    process.exit(1);
  });

// --- Basic Welcome Route ---
app.get("/", (req, res) => res.send("Accessible Learning Portal API is running."));

// --- Global Error Handler ---
app.use((err, req, res, next) => {
  console.error("Unhandled error:", err.stack);
  res.status(err.status || 500).json({
    error: err.message || 'An unexpected error occurred.',
  });
});


const PORT = process.env.PORT || 5000;
app.listen(PORT, () => console.log(`Server running on port ${PORT} in ${process.env.NODE_ENV || 'development'} mode.`));