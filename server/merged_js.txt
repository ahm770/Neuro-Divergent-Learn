
===== File: /utils/auditLogger.js =====
// ===== File: /utils/auditLogger.js =====
const AuditLog = require('../models/AuditLog');

const logAction = async (userId, action, entity, entityId = null, details = {}, ipAddress = null) => {
  try {
    const log = new AuditLog({
      user: userId,
      action,
      entity,
      entityId,
      details,
      ipAddress 
    });
    await log.save();
    // console.log('Audit log created:', action, entity, entityId); 
  } catch (error) {
    console.error('Failed to create audit log:', error.message, error.stack);
  }
};

module.exports = logAction;

===== File: /utils/generateToken.js =====
// ===== File: /utils/generateToken.js =====
const jwt = require('jsonwebtoken');

const generateToken = (id) => {
  // Check if JWT_SECRET is set
  if (!process.env.JWT_SECRET) {
      // Throw an error instead of exiting, so it can be caught by a global error handler or at startup
      throw new Error('FATAL ERROR: JWT_SECRET is not defined in .env file.');
  }

  return jwt.sign({ id }, process.env.JWT_SECRET, {
    expiresIn: '30d', // Token expires in 30 days (adjust as needed)
  });
};

module.exports = generateToken;

===== File: /middleware/authMiddleware.js =====
// ===== File: /middleware/authMiddleware.js =====
const jwt = require('jsonwebtoken');
const User = require('../models/User'); // Adjust path as per your project structure

const protect = async (req, res, next) => {
  let token;

  if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {
    try {
      token = req.headers.authorization.split(' ')[1];
      const decoded = jwt.verify(token, process.env.JWT_SECRET);
      req.user = await User.findById(decoded.id).select('-password');

      if (!req.user) {
        return res.status(401).json({ error: 'Not authorized, user not found' });
      }
      next();
    } catch (error) {
      console.error('Token verification failed:', error.message);
      if (error.name === 'JsonWebTokenError') {
        return res.status(401).json({ error: 'Not authorized, token failed (invalid signature)' });
      }
      if (error.name === 'TokenExpiredError') {
        return res.status(401).json({ error: 'Not authorized, token expired' });
      }
      return res.status(401).json({ error: 'Not authorized, token failed' });
    }
  }

  if (!token) {
    return res.status(401).json({ error: 'Not authorized, no token' });
  }
};

const isAdmin = (req, res, next) => {
  if (req.user && req.user.role === 'admin') {
    next();
  } else {
    res.status(403).json({ error: 'Not authorized as an admin' });
  }
};

const isCreator = (req, res, next) => {
  if (req.user && req.user.role === 'creator') {
    next();
  } else {
    res.status(403).json({ error: 'Not authorized as a creator' });
  }
};

const isCreatorOrAdmin = (req, res, next) => {
  if (req.user && (req.user.role === 'admin' || req.user.role === 'creator')) {
    next();
  } else {
    res.status(403).json({ error: 'Not authorized as an admin or creator' });
  }
};

module.exports = { protect, isAdmin, isCreator, isCreatorOrAdmin };

===== File: /controllers/authController.js =====
const User = require('../models/User');
const generateToken = require('../utils/generateToken');
const { validationResult } = require('express-validator'); // For input validation

// Validation rules (can be moved to a separate validation file later)
const { body } = require('express-validator');

exports.signupValidation = [
  body('name').optional().trim().isLength({ min: 2 }).withMessage('Name must be at least 2 characters'),
  body('email').isEmail().withMessage('Please provide a valid email').normalizeEmail(),
  body('password').isLength({ min: 6 }).withMessage('Password must be at least 6 characters')
];

exports.loginValidation = [
  body('email').isEmail().withMessage('Please provide a valid email').normalizeEmail(),
  body('password').exists().withMessage('Password is required')
];


exports.signup = async (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }

  try {
    const { name, email, password } = req.body;

    const existingUser = await User.findOne({ email: email.toLowerCase() });
    if (existingUser) return res.status(400).json({ error: 'User already exists' });

    const user = await User.create({ name, email, password });

    res.status(201).json({
      _id: user._id,
      name: user.name,
      email: user.email,
      preferences: user.preferences,
      token: generateToken(user._id)
    });

  } catch (err) {
    console.error("Signup error:", err);
    res.status(500).json({ error: err.message || 'Server error during signup' });
  }
};

exports.login = async (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }

  try {
    const { email, password } = req.body;

    const user = await User.findOne({ email: email.toLowerCase() });
    if (!user || !(await user.matchPassword(password))) {
      return res.status(401).json({ error: 'Invalid email or password' });
    }

    res.json({
      _id: user._id,
      name: user.name,
      email: user.email,
      role: user.role,
      preferences: user.preferences,
      token: generateToken(user._id)
    });

  } catch (err) {
    console.error("Login error:", err);
    res.status(500).json({ error: err.message || 'Server error during login' });
  }
};

// Get current logged-in user's profile
exports.getMe = async (req, res) => {
    try {
        // req.user is populated by the 'protect' middleware
        const user = await User.findById(req.user.id).select('-password');
        if (!user) {
            return res.status(404).json({ error: 'User not found' });
        }
        res.json({
            _id: user._id,
            name: user.name,
            email: user.email,
            role: user.role,
            preferences: user.preferences,
            createdAt: user.createdAt
        });
    } catch (err) {
        console.error("GetMe error:", err);
        res.status(500).json({ error: 'Server error fetching user profile' });
    }
};

// Update user preferences
exports.updatePreferences = async (req, res) => {
    try {
        const userId = req.user.id;
        // Destructure all expected preference fields
        const {
            readingLevel,
            fontSize,
            theme,
            dyslexiaFontEnabled, // Added
            preferredContentMode,
            ttsEnabled
        } = req.body;

        const user = await User.findById(userId);
        if (!user) {
            return res.status(404).json({ error: 'User not found' });
        }

        // Validate and update preferences
        if (readingLevel && ['basic', 'intermediate', 'advanced'].includes(readingLevel)) {
            user.preferences.readingLevel = readingLevel;
        }
        if (fontSize && ['small', 'medium', 'large', 'xlarge'].includes(fontSize)) {
            user.preferences.fontSize = fontSize;
        }
        if (theme && ['light', 'dark', 'high-contrast'].includes(theme)) {
            user.preferences.theme = theme;
        }
        if (typeof dyslexiaFontEnabled === 'boolean') { // Added
            user.preferences.dyslexiaFontEnabled = dyslexiaFontEnabled;
        }
        if (preferredContentMode && ['text', 'video', 'visual', 'audio'].includes(preferredContentMode)) {
            user.preferences.preferredContentMode = preferredContentMode;
        }
        if (typeof ttsEnabled === 'boolean') {
            user.preferences.ttsEnabled = ttsEnabled;
        }

        await user.save();
        res.json({
            message: 'Preferences updated successfully',
            preferences: user.preferences // Send back the full updated preferences object
        });

    } catch (err) {
        console.error("UpdatePreferences error:", err);
        res.status(500).json({ error: 'Server error updating preferences' });
    }
};

===== File: /controllers/contentController.js =====
// ===== File: /controllers/contentController.js =====
const Content = require('../models/Content');
const User = require('../models/User');
const { GoogleGenerativeAI, HarmCategory, HarmBlockThreshold } = require("@google/generative-ai");
const logAction = require('../utils/auditLogger'); // Import the logger
const crypto = require('crypto'); // For hashing text in audit

const GOOGLE_API_KEY = process.env.GOOGLE_API_KEY;
let genAI;
let textModel;

if (GOOGLE_API_KEY) {
  try {
    genAI = new GoogleGenerativeAI(GOOGLE_API_KEY);
    textModel = genAI.getGenerativeModel({ model: "gemini-1.5-flash-latest" });
    console.log("Google Generative AI SDK initialized successfully with gemini-1.5-flash-latest.");
  } catch (error) {
    console.error("FATAL: Failed to initialize Google Generative AI SDK:", error.message);
  }
} else {
  console.warn("Warning: GOOGLE_API_KEY is not defined. Google AI features will be disabled.");
}

const mapReadingLevelToPromptDescription = (readingLevel) => {
  switch (readingLevel) {
    case 'basic': return 'an easy-to-understand';
    case 'intermediate': return 'a moderately detailed';
    case 'advanced': return 'an advanced and comprehensive';
    default: return 'an easy-to-understand';
  }
};
const mapReadingLevelToCacheKey = (readingLevel) => {
  switch (readingLevel) {
    case 'basic': return 'easy';
    case 'intermediate': return 'moderate';
    case 'advanced': return 'advanced';
    default: return 'easy';
  }
};

const createContent = async (req, res) => {
  try {
    const { topic, originalText, tags, imageUrls, videoExplainers, audioNarrations } = req.body;
    if (!topic || !originalText) {
      return res.status(400).json({ error: 'Topic and originalText are required.' });
    }
    const topicSlug = topic.toLowerCase().trim().replace(/\s+/g, '-').replace(/[^\w-]+/g, ''); // Sanitize slug
    const existingContent = await Content.findOne({ topic: topicSlug });
    if (existingContent) {
      return res.status(400).json({ error: `Content for topic "${topic}" already exists (slug: ${topicSlug}).` });
    }
    const newContent = new Content({
      topic: topicSlug,
      originalText,
      tags: tags || [],
      media: { imageUrls: imageUrls || [] },
      videoExplainers: videoExplainers || [],
      audioNarrations: audioNarrations || [],
      createdBy: req.user._id 
    });
    await newContent.save();
    
    await logAction(
      req.user.id, 
      'CREATE_CONTENT', 
      'Content', 
      newContent._id, 
      { 
        topicSlug: newContent.topic, 
        titleFromUser: topic,
        tags: newContent.tags,
        charCount: originalText.length 
      },
      req.ip
    );

    const populatedContent = await Content.findById(newContent._id)
                                     .populate('createdBy', 'name email')
                                     .populate('lastUpdatedBy', 'name email');
    res.status(201).json(populatedContent);
  } catch (err) {
    console.error("Error creating content:", err.message, err.stack);
    res.status(500).json({ error: 'Failed to create content' });
  }
};

const getAllContent = async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 10;
    const skip = (page - 1) * limit;

    const query = {};
    if (req.query.search && req.query.search.trim() !== '') {
      const searchRegex = new RegExp(req.query.search.trim(), 'i');
      query.$or = [
        { topic: searchRegex }, // Searches the slug
        { originalText: searchRegex },
        { tags: searchRegex }
      ];
    }
    if (req.query.tag && req.query.tag.trim() !== '') {
        query.tags = { $regex: new RegExp(`^${req.query.tag.trim()}$`, 'i') };
    }
    if (req.query.creatorId) {
        query.createdBy = req.query.creatorId;
    }

    const sortOptions = {};
    if (req.query.sortBy) {
      const parts = req.query.sortBy.split(':');
      sortOptions[parts[0]] = parts[1] === 'desc' ? -1 : 1;
    } else {
      sortOptions.createdAt = -1;
    }

    const contents = await Content.find(query)
      .populate('createdBy', 'name email')
      .populate('lastUpdatedBy', 'name email')
      .sort(sortOptions)
      .skip(skip)
      .limit(limit)
      .select('topic tags originalText createdAt createdBy lastUpdatedBy updatedAt'); // Ensure originalText is selected for dashboard snippets

    const totalContents = await Content.countDocuments(query);
    const totalPages = Math.ceil(totalContents / limit);

    res.json({
      contents,
      currentPage: page,
      totalPages,
      totalContents,
    });
  } catch (err) {
    console.error("Error fetching all content:", err.message, err.stack);
    res.status(500).json({ error: 'Failed to retrieve content list' });
  }
};

const getContentById = async (req, res) => {
    try {
        const content = await Content.findById(req.params.id)
            .populate('createdBy', 'name email')
            .populate('lastUpdatedBy', 'name email');
        if (!content) {
            return res.status(404).json({ message: 'Content not found.' });
        }
        res.json(content);
    } catch (err) {
        console.error("Error fetching content by ID:", err.message, err.stack);
        if (err.kind === 'ObjectId') {
             return res.status(400).json({ message: 'Invalid content ID format.' });
        }
        res.status(500).json({ error: 'Failed to retrieve content' });
    }
};

const updateContent = async (req, res) => {
  try {
    const { topic, originalText, tags, imageUrls, videoExplainers, audioNarrations } = req.body;
    const contentId = req.params.id;
    let content = await Content.findById(contentId);
    if (!content) {
      return res.status(404).json({ error: 'Content not found.' });
    }
    
    const oldValuesSummary = {
        topic: content.topic,
        originalTextHash: crypto.createHash('md5').update(content.originalText || "").digest('hex'),
        tags: [...content.tags],
        imageCount: content.media?.imageUrls?.length || 0,
        videoCount: content.videoExplainers?.length || 0,
        audioCount: content.audioNarrations?.length || 0,
    };
    const changes = {};

    const newSlug = topic ? topic.toLowerCase().trim().replace(/\s+/g, '-').replace(/[^\w-]+/g, '') : content.topic;
    if (topic && content.topic !== newSlug) {
        changes.topic = { old: content.topic, new: newSlug };
        content.topic = newSlug;
    }
    if (originalText && content.originalText !== originalText) {
        changes.originalText = "modified"; // Just indicate change, don't log full text
        content.originalText = originalText;
    }
    if (tags !== undefined && JSON.stringify(content.tags.slice().sort()) !== JSON.stringify(tags.slice().sort())) {
        changes.tags = { old: content.tags, new: tags };
        content.tags = tags;
    }
    if (imageUrls !== undefined && JSON.stringify(content.media.imageUrls.slice().sort()) !== JSON.stringify(imageUrls.slice().sort())) {
        changes.imageUrls = "modified";
        content.media.imageUrls = imageUrls;
    }
    if (videoExplainers !== undefined && JSON.stringify(content.videoExplainers) !== JSON.stringify(videoExplainers)) { // Simplistic comparison
        changes.videoExplainers = "modified";
        content.videoExplainers = videoExplainers;
    }
    if (audioNarrations !== undefined && JSON.stringify(content.audioNarrations) !== JSON.stringify(audioNarrations)) {
        changes.audioNarrations = "modified";
        content.audioNarrations = audioNarrations;
    }
    
    if (Object.keys(changes).length > 0) {
        content.lastUpdatedBy = req.user._id;
    }
    
    const updatedContent = await content.save();

    if (Object.keys(changes).length > 0) {
        await logAction(
          req.user.id,
          'UPDATE_CONTENT',
          'Content',
          updatedContent._id,
          { 
            topicSlug: updatedContent.topic, 
            titleFromUser: topic, // User input title
            changes: changes, // Log specific changes
            // oldValuesSummary: oldValuesSummary // Optional: Log summary of old values
          },
          req.ip
        );
    }

    const populatedContent = await Content.findById(updatedContent._id)
                                    .populate('createdBy', 'name email')
                                    .populate('lastUpdatedBy', 'name email');
    res.json(populatedContent);
  } catch (err) {
    console.error("Error updating content:", err.message, err.stack);
    if (err.kind === 'ObjectId') { return res.status(400).json({ message: 'Invalid content ID format.' }); }
    res.status(500).json({ error: 'Failed to update content' });
  }
};

const deleteContent = async (req, res) => {
  try {
    const contentId = req.params.id;
    const content = await Content.findById(contentId);
    if (!content) { return res.status(404).json({ error: 'Content not found.' }); }

    const deletedTopicSlug = content.topic; 
    const deletedTitle = content.topic.replace(/-/g, ' '); // For audit log
    await content.deleteOne();

    await logAction(
      req.user.id,
      'DELETE_CONTENT',
      'Content',
      contentId, // Use the original ID as entityId
      { topicSlug: deletedTopicSlug, title: deletedTitle },
      req.ip
    );
    res.json({ message: 'Content removed successfully.' });
  } catch (err) {
    console.error("Error deleting content:", err.message, err.stack);
    if (err.kind === 'ObjectId') { return res.status(400).json({ message: 'Invalid content ID format.' });}
    res.status(500).json({ error: 'Failed to delete content' });
  }
};

const getContentByTopic = async (req, res) => {
    try {
        const topicSlug = req.params.topic.toLowerCase().trim();
        const user = req.user ? await User.findById(req.user.id).select('preferences') : null;
        const content = await Content.findOne({ topic: topicSlug })
                                .populate('createdBy', 'name email')
                                .populate('lastUpdatedBy', 'name email');
        if (!content) { return res.status(404).json({ message: `Content not found for topic: ${topicSlug}` });}
        
        let responseContent = { ...content.toObject() };
        if (user?.preferences?.readingLevel) {
            const cacheLevelKey = mapReadingLevelToCacheKey(user.preferences.readingLevel);
            const preferredSimplifiedVersion = content.simplifiedVersions.find(v => v.level === cacheLevelKey);
            if (preferredSimplifiedVersion) {
                responseContent.defaultSimplifiedText = preferredSimplifiedVersion.text;
                responseContent.defaultSimplifiedLevel = preferredSimplifiedVersion.level;
            }
        }
        res.json(responseContent);
    } catch (err) {
        console.error("Error fetching content by topic:", err.message, err.stack);
        res.status(500).json({ error: 'Failed to retrieve content' });
    }
};

const simplifyContent = async (req, res) => {
  if (!GOOGLE_API_KEY || !textModel) {
    console.error("Google AI SDK (textModel) not initialized for simplifyContent.");
    return res.status(500).json({ error: "AI service is not configured." });
  }
  try {
    const { topic: topicSlug } = req.body;
    let { level: clientRequestedLevel } = req.body;
    if (!topicSlug) { return res.status(400).json({ error: "Topic slug is required." }); }

    let promptLevelDescription;
    let cacheLevelKey;
    if (!clientRequestedLevel) {
      const userId = req.user?._id;
      let userReadingLevelPref = 'basic';
      if (userId) {
        const user = await User.findById(userId).select('preferences');
        if (user?.preferences?.readingLevel) userReadingLevelPref = user.preferences.readingLevel;
      }
      promptLevelDescription = mapReadingLevelToPromptDescription(userReadingLevelPref);
      cacheLevelKey = mapReadingLevelToCacheKey(userReadingLevelPref);
    } else {
      promptLevelDescription = mapReadingLevelToPromptDescription(clientRequestedLevel);
      cacheLevelKey = mapReadingLevelToCacheKey(clientRequestedLevel);
    }

    let contentDoc = await Content.findOne({ topic: topicSlug.toLowerCase().trim() });
    if (!contentDoc) { return res.status(404).json({ error: `Content for topic "${topicSlug}" not found.` });}

    const existingSimplified = contentDoc.simplifiedVersions.find(v => v.level === cacheLevelKey);
    if (existingSimplified) {
      return res.json({ simplifiedText: existingSimplified.text, level: cacheLevelKey });
    }

    console.log(`Generating new simplified version (Gemini) for: ${contentDoc.topic}, prompt level: "${promptLevelDescription}"`);
    const simplificationPrompt = `You are an expert tutor specialized in adapting complex educational text for neurodivergent learners. Your goal is to simplify the following text while preserving its core meaning and accuracy. Adapt your language to suit a '${promptLevelDescription}' reading level. Use clear, concise sentences, and break down complex ideas into smaller, digestible parts. Avoid jargon where possible, or explain it simply if essential. If relevant, use analogies or simple examples. Ensure the tone is encouraging and supportive. Do NOT add any preambles like "Okay, here's the simplified version". Directly provide the simplified text. Original Text:\n---\n${contentDoc.originalText}\n---\n\nSimplified Text (for ${promptLevelDescription} understanding):`;
    const safetySettings = [ { category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE }, { category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE }, { category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE }, { category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE }, ];
    const generationConfig = { temperature: 0.3, maxOutputTokens: 2000 }; 
    
    const result = await textModel.generateContent({ contents: [{ role: "user", parts: [{ text: simplificationPrompt }] }], generationConfig, safetySettings });
    const response = result.response;

    if (!response || !response.candidates || response.candidates.length === 0 || !response.candidates[0].content?.parts) {
        const blockReason = response?.promptFeedback?.blockReason || response?.candidates?.[0]?.finishReason;
        console.error("Content generation issue with Google Gemini (simplify):", { blockReason, safetyRatings: response?.candidates?.[0]?.safetyRatings, fullResponse: JSON.stringify(response, null, 2) });
        let userMessage = 'AI failed to generate simplified content.';
        if (blockReason === "SAFETY" || response?.candidates?.[0]?.finishReason === "SAFETY") { userMessage = 'Content could not be simplified due to safety filters.';}
        else if (blockReason) { userMessage = `Content generation blocked: ${blockReason}.`;}
        return res.status(400).json({ error: userMessage });
    }
    const simplifiedText = response.candidates[0].content.parts.map(part => part.text).join("").trim();
    contentDoc.simplifiedVersions.push({ level: cacheLevelKey, text: simplifiedText, createdAt: new Date() });
    content.lastUpdatedBy = req.user._id;
    await contentDoc.save();

    await logAction(
        req.user.id,
        'GENERATE_SIMPLIFIED_CONTENT',
        'Content',
        contentDoc._id,
        { topic: contentDoc.topic, level: cacheLevelKey },
        req.ip
    );

    res.json({ simplifiedText, level: cacheLevelKey });
  } catch (err) {
    console.error("Error in simplifyContent (Google Gemini):", err.message, err.stack);
    let userMessage = 'Failed to simplify content using Google AI.';
    if (err.message.toLowerCase().includes("api key") || err.message.toLowerCase().includes("permission denied")) { userMessage = "Google AI API key is invalid or not authorized."; return res.status(401).json({ error: userMessage });}
    if (err.message.toLowerCase().includes("quota") || err.message.toLowerCase().includes("rate limit")) { userMessage = "Google AI API quota exceeded."; return res.status(429).json({ error: userMessage });}
    res.status(500).json({ error: userMessage });
  }
};

const generateVisualMap = async (req, res) => {
  if (!GOOGLE_API_KEY || !textModel) {
    console.error("Google AI SDK (textModel) not initialized for generateVisualMap.");
    return res.status(500).json({ error: "AI service is not configured." });
  }
  try {
    const { topic: topicSlug, format = 'mermaid' } = req.body;
    if (!topicSlug) { return res.status(400).json({ error: "Topic slug is required." }); }
    if (format !== 'mermaid') { return res.status(400).json({ error: "Only 'mermaid' format supported."}); }

    let contentDoc = await Content.findOne({ topic: topicSlug.toLowerCase().trim() });
    if (!contentDoc) { return res.status(404).json({ error: `Content for topic "${topicSlug}" not found.`});}

    const existingMap = contentDoc.visualMaps?.find(v => v.format === format);
    if (existingMap) { return res.json({ visualMap: existingMap }); }

    console.log(`Generating new visual map (Gemini) for: ${contentDoc.topic}, format: ${format}`);
    const visualMapPrompt = `
      You are an expert in creating educational diagrams.
      From the following educational text about "${contentDoc.topic.replace(/-/g, ' ')}", generate **valid MermaidJS mindmap syntax**.
      The mindmap should clearly represent the key concepts and their hierarchical relationships as described in the text.
      - The main topic, "${contentDoc.topic.replace(/-/g, ' ')}", should be the root node, styled like this: root((Main Topic)).
      - Use **indentation** to define parent-child relationships. Each level of indentation creates a new sub-level in the mindmap.
      - Do NOT use any custom keywords like "sub(...)" or "end". Only use standard Mermaid mindmap indentation.

      Here is an example of the correct Mermaid mindmap syntax structure:
      mindmap
        root((Example Main Topic))
          Level 1 Child A
            Level 2 Grandchild A.1
            Level 2 Grandchild A.2
          Level 1 Child B
            Level 2 Grandchild B.1
          Another Level 1 Child

      The output should ONLY be the MermaidJS code block itself, starting with the word "mindmap". Do not include any other explanatory text, markdown formatting (like \`\`\`mermaid or \`\`\`), or any words before or after the MermaidJS code. Just the pure MermaidJS syntax.

      Original Text (excerpt, max 3500 chars):
      ---
      ${contentDoc.originalText.substring(0, 3500)} 
      ---

      MermaidJS Mindmap Code:
    `;
    const safetySettings = [ { category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE }, { category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE }, { category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE }, { category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE }, ];
    const generationConfig = { temperature: 0.1, maxOutputTokens: 1500 }; 
    const result = await textModel.generateContent({ contents: [{ role: "user", parts: [{ text: visualMapPrompt }] }], generationConfig, safetySettings });
    const response = result.response;

    if (!response || !response.candidates || response.candidates.length === 0 || !response.candidates[0].content?.parts) {
        const blockReason = response?.promptFeedback?.blockReason || response?.candidates?.[0]?.finishReason;
        console.error("Visual map generation issue with Google Gemini:", { blockReason, fullResponse: JSON.stringify(response, null, 2) });
        let userMessage = 'AI failed to generate visual map.';
        if (blockReason === "SAFETY" || response?.candidates?.[0]?.finishReason === "SAFETY") { userMessage = 'Visual map could not be generated due to safety filters.';}
        else if (blockReason) { userMessage = `Visual map generation blocked: ${blockReason}.`;}
        return res.status(400).json({ error: userMessage });
    }
    let mermaidData = response.candidates[0].content.parts.map(part => part.text).join("").trim();
    mermaidData = mermaidData.replace(/^```mermaid\s*\n?([\s\S]*?)\n?```$/, '$1').trim();
    mermaidData = mermaidData.replace(/^```\s*\n?([\s\S]*?)\n?```$/, '$1').trim();

    const newVisualMap = { format, data: mermaidData, createdAt: new Date(), notes: "AI-Generated (Gemini)" };
    contentDoc.visualMaps.push(newVisualMap);
    content.lastUpdatedBy = req.user._id;
    await contentDoc.save();

    await logAction(
        req.user.id,
        'GENERATE_VISUAL_MAP',
        'Content',
        contentDoc._id,
        { topic: contentDoc.topic, format: format },
        req.ip
    );

    res.json({ visualMap: newVisualMap });
  } catch (err) {
    console.error("Error in generateVisualMap (Google Gemini):", err.message, err.stack);
    let userMessage = 'Failed to generate visual map using Google AI.';
    if (err.message.toLowerCase().includes("api key") || err.message.toLowerCase().includes("permission denied")) { userMessage = "Google AI API key is invalid or not authorized."; return res.status(401).json({ error: userMessage });}
    if (err.message.toLowerCase().includes("quota") || err.message.toLowerCase().includes("rate limit")) { userMessage = "Google AI API quota exceeded."; return res.status(429).json({ error: userMessage });}
    res.status(500).json({ error: userMessage });
  }
};

const generateAudioNarration = async (req, res) => {
    const { contentId, textToNarrate } = req.body;
    if (!contentId || !textToNarrate) {
        return res.status(400).json({error: "Content ID and text are required."});
    }
     const content = await Content.findById(contentId);
     if (!content) {
        return res.status(404).json({error: "Content not found."});
     }
    // Placeholder logic as actual AI generation is complex
    // In a real scenario, you'd call a TTS service, get a URL, and save it.
    const placeholderUrl = `https://example.com/audio/${contentId}-${Date.now()}.mp3`;
    const newNarration = {
        url: placeholderUrl,
        language: 'en-US', // Or from user prefs/request
        voice: 'default',
        createdAt: new Date()
    };
    content.audioNarrations.push(newNarration);
    content.lastUpdatedBy = req.user._id;
    await content.save();
    
    await logAction(
        req.user.id, 
        'GENERATE_AUDIO_NARRATION', 
        'Content', 
        contentId, 
        { topic: content.topic, url: placeholderUrl, source: "placeholder" }, 
        req.ip
    );
    res.status(201).json({ message: "Audio narration URL placeholder created.", narration: newNarration });
};
const findVideoExplainers = async (req, res) => {
  res.status(501).json({ error: "Video explainer sourcing not implemented." });
};

module.exports = {
  createContent,
  getAllContent,
  getContentById,
  updateContent,
  deleteContent,
  getContentByTopic,
  simplifyContent,
  generateVisualMap,
  generateAudioNarration,
  findVideoExplainers,
};

===== File: /controllers/qaController.js =====
// ===== File: /controllers/qaController.js =====
const axios = require('axios');
const Session = require('../models/Session');
const Content = require('../models/Content');
const User = require('../models/User'); // To get user preferences

const OPENROUTER_API_KEY = process.env.OPENROUTER_API_KEY;
const OPENROUTER_DEFAULT_MODEL = process.env.OPENROUTER_DEFAULT_MODEL || 'mistralai/mistral-7b-instruct:free';
const YOUR_SITE_URL = process.env.YOUR_SITE_URL || 'http://localhost:3000';
const YOUR_SITE_NAME = process.env.YOUR_SITE_NAME || 'AccessibleLearningPortal';

// Helper to map user reading level to simplification level for context
const mapReadingLevelToSimplifyLevel = (readingLevel) => {
  switch (readingLevel) {
    case 'basic': return 'easy';
    case 'intermediate': case 'advanced': return 'moderate';
    default: return 'easy';
  }
};

exports.askQuestion = async (req, res) => {
  try {
    const { question, topic } = req.body;
    const userId = req.user._id;

    if (!question || !topic) {
      return res.status(400).json({ error: 'Question and topic are required.' });
    }

    const user = await User.findById(userId).select('preferences');
    const userReadingLevel = user?.preferences?.readingLevel || 'basic';
    const preferredSimplifyLevel = mapReadingLevelToSimplifyLevel(userReadingLevel);

    // 1. Fetch context based on the topic
    const content = await Content.findOne({ topic: topic.toLowerCase().trim() });
    let contextText = "General knowledge.";
    let contextUsed = 'general_knowledge';

    if (content) {
        // Prioritize using a simplified version matching user's preference if available
        const preferredSimplifiedVersion = content.simplifiedVersions.find(v => v.level === preferredSimplifyLevel);
        if (preferredSimplifiedVersion) {
            contextText = preferredSimplifiedVersion.text;
            contextUsed = `simplified_${preferredSimplifyLevel}`;
        } else {
            // Fallback to any 'easy' simplified version if preferred not found
            const easyVersion = content.simplifiedVersions.find(v => v.level === 'easy');
            if (easyVersion) {
                contextText = easyVersion.text;
                contextUsed = 'simplified_easy';
            } else {
                contextText = content.originalText; // Fallback to original if no suitable simplified version
                contextUsed = 'original';
            }
        }
    } else {
         console.warn(`Content not found for topic "${topic}" in QA, using general context.`);
    }

    // 2. Construct prompt for LLM, incorporating user preference for clarity
    let promptIntro = `You are a friendly, patient, and helpful tutor for a neurodivergent student. The student prefers explanations that are very clear, simple, and tailored for a '${userReadingLevel}' reading level.`;
    if (user?.preferences?.preferredContentMode === 'visual') {
        promptIntro += " The student sometimes benefits from analogies or visualizable descriptions if appropriate for the question."
    }

    const prompt = `${promptIntro}
Context on the topic "${topic}":
---
${contextText.substring(0, 2500)}
---
Based *primarily* on the provided context, answer the student's question. If the context is insufficient, you may use your general knowledge but state that you are doing so. If the question is completely outside the context and your general knowledge, clearly say you don't have the information.
Student's Question: "${question}"
Answer:`;

    // 3. Call OpenRouter API
    const response = await axios.post(
      'https://openrouter.ai/api/v1/chat/completions',
      {
        model: OPENROUTER_DEFAULT_MODEL,
        messages: [
          // System message sets the persona more broadly
          { role: 'system', content: `You are a friendly, patient, and helpful tutor for a neurodivergent student who needs clear and simple explanations. Adapt your language complexity to a '${userReadingLevel}' reading level.` },
          { role: 'user', content: prompt }
        ],
        // max_tokens: 200 // Optionally limit response length
      },
      {
        headers: {
          'Authorization': `Bearer ${OPENROUTER_API_KEY}`,
          'Content-Type': 'application/json',
          'HTTP-Referer': YOUR_SITE_URL,
          'X-Title': YOUR_SITE_NAME
        }
      }
    );

    if (!response.data || !response.data.choices || response.data.choices.length === 0 || !response.data.choices[0].message) {
        console.error("Invalid response structure from OpenRouter API:", response.data);
        throw new Error('Invalid response structure from OpenRouter API');
    }

    const answer = response.data.choices[0].message.content.trim();

    // 4. Log interaction
    await Session.findOneAndUpdate(
        { userId: userId },
        {
            $push: {
                interactions: {
                    question: question,
                    answer: answer,
                    topic: topic,
                    contextUsed: contextUsed // Log which context was used
                }
            },
            $setOnInsert: { createdAt: new Date() }
        },
        { upsert: true, new: true }
    );

    res.json({ answer });

  } catch (err) {
    console.error("Error in askQuestion:", err.response ? JSON.stringify(err.response.data, null, 2) : err.message, err.stack);
    res.status(500).json({ error: err.message || 'Failed to get answer' });
  }
};

===== File: /controllers/userController.js =====
// ===== File: /controllers/userController.js =====
const User = require('../models/User');
const mongoose = require('mongoose');
const logAction = require('../utils/auditLogger');

exports.getAllUsers = async (req, res) => {
    try {
        const page = parseInt(req.query.page) || 1;
        const limit = parseInt(req.query.limit) || 10;
        const skip = (page - 1) * limit;

        const query = {};
        if (req.query.search && req.query.search.trim() !== '') {
            const searchRegex = new RegExp(req.query.search.trim(), 'i');
            query.$or = [ { name: searchRegex }, { email: searchRegex } ];
        }
        if (req.query.role && ['user', 'creator', 'admin'].includes(req.query.role)) {
            query.role = req.query.role;
        }

        const sortOptions = {};
        if (req.query.sortBy) {
            const parts = req.query.sortBy.split(':');
            sortOptions[parts[0]] = parts[1] === 'desc' ? -1 : 1;
        } else {
            sortOptions.createdAt = -1;
        }

        const users = await User.find(query)
            .select('-password')
            .sort(sortOptions)
            .skip(skip)
            .limit(limit);

        const totalUsers = await User.countDocuments(query);
        const totalPages = Math.ceil(totalUsers / limit);

        res.json({ users, currentPage: page, totalPages, totalUsers });
    } catch (error) {
        console.error("Get All Users Error:", error);
        res.status(500).json({ error: 'Server error fetching users' });
    }
};

exports.getUserById = async (req, res) => {
    try {
        if (!mongoose.Types.ObjectId.isValid(req.params.id)) {
            return res.status(400).json({ error: 'Invalid user ID format' });
        }
        const user = await User.findById(req.params.id).select('-password');
        if (!user) { return res.status(404).json({ error: 'User not found' }); }
        res.json(user);
    } catch (error) {
        console.error("Get User By ID Error:", error);
        res.status(500).json({ error: 'Server error fetching user' });
    }
};

exports.updateUserRole = async (req, res) => {
    try {
        if (!mongoose.Types.ObjectId.isValid(req.params.id)) {
            return res.status(400).json({ error: 'Invalid user ID format' });
        }
        const { role } = req.body;
        if (!['user', 'creator', 'admin'].includes(role)) {
            return res.status(400).json({ error: 'Invalid role specified' });
        }

        const user = await User.findById(req.params.id);
        if (!user) { return res.status(404).json({ error: 'User not found' }); }

        if (user.id.toString() === req.user.id && user.role === 'admin' && role !== 'admin') {
            const adminCount = await User.countDocuments({ role: 'admin' });
            if (adminCount <= 1) {
                return res.status(400).json({ error: 'Cannot remove the last admin role.' });
            }
        }
        
        const oldRole = user.role;
        if (oldRole === role) { // No change
             const userToReturn = user.toObject();
             delete userToReturn.password;
             return res.json(userToReturn);
        }
        user.role = role;
        await user.save();
        
        await logAction(
            req.user.id, 
            'UPDATE_USER_ROLE',
            'User',
            user._id, 
            { targetUserId: user._id.toString(), targetUserEmail: user.email, oldRole: oldRole, newRole: role },
            req.ip
        );

        const userToReturn = user.toObject();
        delete userToReturn.password;
        res.json(userToReturn);
    } catch (error) {
        console.error("Update User Role Error:", error);
        res.status(500).json({ error: 'Server error updating user role' });
    }
};

exports.deleteUserCtrl = async (req, res) => {
    try {
        if (!mongoose.Types.ObjectId.isValid(req.params.id)) {
            return res.status(400).json({ error: 'Invalid user ID format' });
        }
        const userToDelete = await User.findById(req.params.id); // Renamed variable
        if (!userToDelete) { return res.status(404).json({ error: 'User not found' }); }

        if (req.user.id === userToDelete.id.toString()) {
             return res.status(400).json({ error: 'Admin cannot delete themselves.' });
        }
        
        const deletedUserEmail = userToDelete.email;
        const deletedUserId = userToDelete._id.toString(); // Capture ID before deletion
        await userToDelete.deleteOne(); 
        
        await logAction(
            req.user.id, 
            'DELETE_USER',
            'User',
            deletedUserId, // Use the string ID here for consistency if entityId is not always ObjectId
            { targetUserId: deletedUserId, targetUserEmail: deletedUserEmail },
            req.ip
        );

        res.json({ message: 'User removed successfully' });
    } catch (error) {
        console.error("Delete User Error:", error);
        res.status(500).json({ error: 'Server error deleting user' });
    }
};

===== File: /models/AuditLog.js =====
// ===== File: /models/AuditLog.js =====
const mongoose = require('mongoose');

const auditLogSchema = new mongoose.Schema({
  user: { 
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  action: { 
    type: String,
    required: true
  },
  entity: { 
    type: String,
    required: true
  },
  entityId: { 
    type: mongoose.Schema.Types.ObjectId,
  },
  details: { 
    type: mongoose.Schema.Types.Mixed 
  },
  ipAddress: { 
    type: String
  },
  timestamp: {
    type: Date,
    default: Date.now
  }
});

module.exports = mongoose.model('AuditLog', auditLogSchema);

===== File: /models/Content.js =====
const mongoose = require('mongoose');

const simplifiedSchema = new mongoose.Schema({
  level: { 
    type: String,
    enum: ['easy', 'moderate', 'advanced'],
    required: true
  },
  text: { type: String },
  createdAt: { type: Date, default: Date.now }
}, { _id: false });

const visualMapSchema = new mongoose.Schema({
  format: { type: String, enum: ['mermaid', 'json_graph', 'text_outline'], default: 'text_outline' },
  data: { type: String, required: true },
  notes: String,
  createdAt: { type: Date, default: Date.now }
}, { _id: false });


const contentSchema = new mongoose.Schema({
  topic: {
    type: String,
    required: true,
    unique: true,
    lowercase: true,
    trim: true
  },
  originalText: {
    type: String,
    required: true
  },
  simplifiedVersions: [simplifiedSchema],
  visualMaps: [visualMapSchema],
  audioNarrations: [
    {
      language: { type: String, default: 'en-US' },
      voice: { type: String, default: 'default' },
      url: { type: String, required: true },
      createdAt: { type: Date, default: Date.now }
    }
  ],
  videoExplainers: [
    {
      source: { type: String, enum: ['youtube', 'vimeo', 'custom_upload', 'generated'], default: 'youtube' },
      url: { type: String, required: true },
      title: String,
      description: String,
      createdAt: { type: Date, default: Date.now }
    }
  ],
  tags: [String],
  media: {
    imageUrls: [String],
  },
  createdBy: { 
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
  },
  lastUpdatedBy: { 
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  createdAt: {
    type: Date,
    default: Date.now
  },
  updatedAt: {
    type: Date,
    default: Date.now
  }
});

contentSchema.pre('save', function(next) {
  if (this.isModified()) {
    this.updatedAt = Date.now();
  }
  next();
});

module.exports = mongoose.model('Content', contentSchema);

===== File: /models/Session.js =====
const mongoose = require('mongoose');

const sessionSchema = new mongoose.Schema({
  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  interactions: [
    {
      question: String,
      answer: String,
      topic: String, // Added topic field
      contextUsed: String, // e.g., 'original', 'simplified_easy', 'general_knowledge'
      timestamp: { type: Date, default: Date.now }
    }
  ],
  createdAt: { type: Date, default: Date.now }
});

module.exports = mongoose.model('Session', sessionSchema);

===== File: /models/User.js =====
// ===== File: /models/User.js =====
const mongoose = require('mongoose');
const bcrypt = require('bcrypt');

const userSchema = new mongoose.Schema({
  name: { type: String },
  email: { type: String, required: true, unique: true, lowercase: true, trim: true },
  password: { type: String, required: true },

  role: {
    type: String,
    enum: ['user', 'creator', 'admin'], // Added 'creator'
    default: 'user'
  },

  preferences: {
    readingLevel: { type: String, default: 'basic', enum: ['basic', 'intermediate', 'advanced'] },
    fontSize: { type: String, default: 'medium', enum: ['small', 'medium', 'large', 'xlarge'] },
    theme: { type: String, default: 'light', enum: ['light', 'dark', 'high-contrast'] },
    dyslexiaFontEnabled: { type: Boolean, default: false },
    preferredContentMode: { type: String, default: 'text', enum: ['text', 'video', 'visual', 'audio']},
    ttsEnabled: { type: Boolean, default: false }
  },

  createdAt: { type: Date, default: Date.now }
});

// ... rest of the User model (pre-save hook, matchPassword method) ...
userSchema.pre('save', async function (next) {
  if (!this.isModified('password')) return next();
  const salt = await bcrypt.genSalt(10);
  this.password = await bcrypt.hash(this.password, salt);
  next();
});

userSchema.methods.matchPassword = async function (enteredPassword) {
  return await bcrypt.compare(enteredPassword, this.password);
};

module.exports = mongoose.model('User', userSchema);

===== File: /routes/authRoutes.js =====
const express = require('express');
const router = express.Router();
const { signup, login, getMe, updatePreferences, signupValidation, loginValidation } = require('../controllers/authController');
const { protect } = require('../middleware/authMiddleware');

router.post('/signup', signupValidation, signup);
router.post('/login', loginValidation, login);
router.get('/me', protect, getMe); // New route to get current user profile
router.put('/preferences', protect, updatePreferences); // New route to update preferences

module.exports = router;

===== File: /routes/contentRoutes.js =====
// ===== File: /server/routes/contentRoutes.js =====
const express = require('express');
const router = express.Router();
const contentController = require('../controllers/contentController');
const { protect, isAdmin, isCreatorOrAdmin } = require('../middleware/authMiddleware'); // Import isCreatorOrAdmin

// --- Routes for general users (protected) ---
router.get('/', protect, contentController.getAllContent); // For dashboard topic list
router.get('/topic/:topic', protect, contentController.getContentByTopic);
router.post('/simplify', protect, contentController.simplifyContent);
router.post('/visual-map', protect, contentController.generateVisualMap);
// Add routes for audio/video generation/sourcing for users later if needed

// --- CRUD Routes for Content (Protected, Creator or Admin) ---
router.post('/create', protect, isCreatorOrAdmin, contentController.createContent);
// Admin or Creator can get by ID for management/editing
router.get('/:id', protect, isCreatorOrAdmin, contentController.getContentById); 
router.put('/:id', protect, isCreatorOrAdmin, contentController.updateContent);
router.delete('/:id', protect, isCreatorOrAdmin, contentController.deleteContent);

// --- Routes for Audio/Video generation (Creator or Admin-focused initially) ---
router.post('/generate-audio', protect, isCreatorOrAdmin, contentController.generateAudioNarration);
router.post('/find-videos', protect, isCreatorOrAdmin, contentController.findVideoExplainers);


module.exports = router;

===== File: /routes/qaRoutes.js =====
// ===== File: /routes/qaRoutes.js =====
const express = require('express');
const router = express.Router();
const qaController = require('../controllers/qaController');
const { protect } = require('../middleware/authMiddleware'); // Import middleware

// POST a question - Requires user to be logged in
router.post('/ask', protect, qaController.askQuestion);

module.exports = router;

===== File: /routes/userRoutes.js =====
// ===== File: /routes/userRoutes.js =====
const express = require('express');
const router = express.Router();
const { getAllUsers, getUserById, updateUserRole, deleteUserCtrl } = require('../controllers/userController');
const { protect, isAdmin } = require('../middleware/authMiddleware');

// All user management routes are admin-only
router.use(protect);
router.use(isAdmin);

router.get('/', getAllUsers);
router.get('/:id', getUserById);
router.put('/:id/role', updateUserRole); // Specific endpoint for updating role
router.delete('/:id', deleteUserCtrl);

module.exports = router;

===== File: /app.js =====
const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const helmet = require('helmet'); // For security headers
const morgan = require('morgan'); // For request logging

require('dotenv').config();

// --- Environment Variable Check ---
const requiredEnvVars = [
  'MONGO_URI',
  'JWT_SECRET',
  'OPENROUTER_API_KEY',
  // 'YOUR_SITE_URL', // Recommended, but provide defaults in controllers if not set
  // 'YOUR_SITE_NAME', // Recommended, but provide defaults if not set
  // 'OPENROUTER_DEFAULT_MODEL' // Has a default in controllers
];
for (const envVar of requiredEnvVars) {
  if (!process.env[envVar]) {
    console.error(`FATAL ERROR: Environment variable ${envVar} is not defined.`);
    process.exit(1);
  }
}

const app = express();

// --- Middleware ---
const corsOptions = {
  origin: [ 
    "http://127.0.0.1:3000",
    "http://localhost:3000",
    "http://[::1]:3000",
    process.env.FRONTEND_URL, 
    "https://opulent-garbanzo-975vgqvp4jj4cg6x-3000.app.github.dev" 
  ].filter(Boolean), 
  credentials: true,
  methods: "GET,HEAD,PUT,PATCH,POST,DELETE",
  preflightContinue: false,
  optionsSuccessStatus: 200
};
app.use(cors(corsOptions));
app.use(helmet()); 
app.use(express.json({ limit: '10mb' })); 
app.use(express.urlencoded({ extended: true, limit: '10mb' })); 

if (process.env.NODE_ENV === 'development') {
  app.use(morgan('dev')); 
}

// --- Routes ---
const authRoutes = require('./routes/authRoutes');
const contentRoutes = require('./routes/contentRoutes');
const qaRoutes = require('./routes/qaRoutes');
const userRoutes = require('./routes/userRoutes'); // Added userRoutes

app.use('/api/auth', authRoutes);
app.use('/api/content', contentRoutes);
app.use('/api/qa', qaRoutes);
app.use('/api/users', userRoutes); // Added userRoutes registration


// --- Database Connection ---
mongoose.connect(process.env.MONGO_URI)
  .then(() => console.log("MongoDB connected successfully."))
  .catch(err => {
    console.error("MongoDB connection error:", err.message);
    process.exit(1); 
  });

// --- Basic Welcome Route ---
app.get("/", (req, res) => res.send("Accessible Learning Portal API is running."));

// --- Global Error Handler ---
app.use((err, req, res, next) => {
  console.error("Unhandled error:", err.stack);
  res.status(err.status || 500).json({
    error: err.message || 'An unexpected error occurred.',
  });
});


const PORT = process.env.PORT || 5000;
app.listen(PORT, () => console.log(`Server running on port ${PORT} in ${process.env.NODE_ENV || 'development'} mode.`));